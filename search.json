[{"title":"Docker 部署 MySQL","path":"/2023/01/19/problem20230119/","content":"使用docker部署MySQL的步骤 拉取官方镜像并创建容器拉取官方最新镜像 根据镜像创建容器 123456docker run -p 3306:3306 --name mysql_test \\-v /usr/local/docker/mysql/conf:/etc/mysql \\-v /usr/local/docker/mysql/logs:/var/log/mysql \\-v /usr/local/docker/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=password \\-d mysql–name：容器名，此处命名为mysql_test-e：配置信息，此处配置mysql的root用户的登陆密码-p：端口映射，此处映射 主机3306端口 到 容器的3306端口-d: 表示使得容器后台一直运行-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录 如果启动失败，可能是容器下的&#x2F;etc&#x2F;mysql内mysql.d不存在，需要先新建一个无映射的mysql容器，并使用cp命令将对应的&#x2F;etc&#x2F;mysql目录复制到宿主机的&#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;conf下 连接MySQL执行bash命令并登录 创建新用户，设定密码为mysql_native_password便于远程登陆 修改用户权限 刷新权限","tags":["docker"],"categories":["日常问题解决"]},{"title":"使用 Apollo 搭建 Spring Boot 配置中心","path":"/2023/01/16/problem20230117/","content":"监测程序的分布式部署需要一个中心节点控制各监测节点的配置，Spring Cloud Config 看起来太复杂了，这里采用Apollo配置中心进行配置管理 根据官方文档进行部署，并记录相关步骤 MySQL搭建采用Docker搭建MySQL数据库，具体操作参见： Docker部署MySQLhttps://gisove.com/2023/01/19/problem20230119/ Apollo服务端共需要两个数据库：ApolloPortalDB和ApolloConfigDB，导入数据库即可： 导入后通过如下语句进行验证： Apollo搭建使用Docker进行Apollo搭建 Apollo Config Service获取镜像 根据镜像创建容器 12345docker run -p 8080:8080 \\ -e SPRING_DATASOURCE_URL=&quot;jdbc:mysql://fill-in-the-correct-server:3306/ApolloConfigDB?characterEncoding=utf8&quot; \\ -e SPRING_DATASOURCE_USERNAME=FillInCorrectUser -e SPRING_DATASOURCE_PASSWORD=FillInCorrectPassword \\ -d -v /tmp/logs:/opt/logs --name apollo-configservice apolloconfig/apollo-configservice:$&#123;version&#125; 参数说明：SPRING_DATASOURCE_URL: 对应环境ApolloConfigDB的地址SPRING_DATASOURCE_USERNAME: 对应环境ApolloConfigDB的用户名SPRING_DATASOURCE_PASSWORD: 对应环境ApolloConfigDB的密码 Apollo Admin Service获取镜像 根据镜像创建容器 12345docker run -p 8090:8090 \\ -e SPRING_DATASOURCE_URL=&quot;jdbc:mysql://fill-in-the-correct-server:3306/ApolloConfigDB?characterEncoding=utf8&quot; \\ -e SPRING_DATASOURCE_USERNAME=FillInCorrectUser -e SPRING_DATASOURCE_PASSWORD=FillInCorrectPassword \\ -d -v /tmp/logs:/opt/logs --name apollo-adminservice apolloconfig/apollo-adminservice:$&#123;version&#125; 参数说明：SPRING_DATASOURCE_URL: 对应环境ApolloConfigDB的地址SPRING_DATASOURCE_USERNAME: 对应环境ApolloConfigDB的用户名SPRING_DATASOURCE_PASSWORD: 对应环境ApolloConfigDB的密码 Apollo Portal获取镜像 根据镜像创建容器 1234567docker run -p 8070:8070 \\ -e SPRING_DATASOURCE_URL=&quot;jdbc:mysql://fill-in-the-correct-server:3306/ApolloPortalDB?characterEncoding=utf8&quot; \\ -e SPRING_DATASOURCE_USERNAME=FillInCorrectUser -e SPRING_DATASOURCE_PASSWORD=FillInCorrectPassword \\ -e APOLLO_PORTAL_ENVS=dev,pro \\ -e DEV_META=http://fill-in-dev-meta-server:8080 -e PRO_META=http://fill-in-pro-meta-server:8080 \\ -d -v /tmp/logs:/opt/logs --name apollo-portal apolloconfig/apollo-portal:$&#123;version&#125; 参数说明：SPRING_DATASOURCE_URL: 对应环境ApolloPortalDB的地址SPRING_DATASOURCE_USERNAME: 对应环境ApolloPortalDB的用户名SPRING_DATASOURCE_PASSWORD: 对应环境ApolloPortalDB的密码APOLLO_PORTAL_ENVS(可选): 对应ApolloPortalDB中的apollo.portal.envs配置项，如果没有在数据库中配置的话，可以通过此环境参数配置DEV_META&#x2F;PRO_META(可选): 配置对应环境的Meta Service地址，以${ENV}_META命名，需要注意的是如果配置了ApolloPortalDB中的apollo.portal.meta.servers配置，则以apollo.portal.meta.servers中的配置为准 Apollo管理界面可以通过 http://fill-in-the-correct-server:8070 来访问Apollo的管理界面，输入用户名apollo，密码admin登陆账号 通过管理员工具&nbsp;→&nbsp;系统参数&nbsp;→&nbsp;Key&nbsp;→&nbsp;查询可以查看相应系统配置，以organizations举例，可以查看当前的部门配置，并进行修改保存。 Error: Admin Services Not Found在管理员工具&nbsp;→&nbsp;系统信息界面发现环境异常，Admin Services Not Found： 通过Docker log查看日志，发现请求出错 将localhost改为真实IP后重启容器，报错消失 客户端配置客户端配置较为简单，在配置文件内加入下列参数： 123456789101112131415161718192021222324#apollo相关配置#app: # 与Apollo Portal上面创建的app id保持一致 id: testapollo: # 就是apollo config server的地址 meta: http://fill-in-the-correct-server:8080 bootstrap: # 是否开启 Apollo enabled: true eagerLoad: # 将 Apollo 加载提到初始化日志系统之前，如果设置为false，则配置中心中修改日志信息不会生效 enabled: true # apollo配置中心文件默认是.properties，如果apollo配置中心中的配置是放在*.yml文件中，此处的namespaces参数要完整的加上.yml后缀，否则不会生效 namespaces: application.yml, application,rsgis.application.yml # 为了防止配置中心无法连接等问题，Apollo可以通过该配置在本地缓存一份配置 cacheDir: ./config # 刷新时间,单位：分钟，默认5 refreshInterval: 5 # 指定使用哪个集群的配置 cluster: default#对应apollo配置中心环境env: DEV 之后在springboot启动类添加注解@EnableApolloConfig即可 Error: Docker虚拟IP地址测试时持续报错，发现程序一直在请求Docker的虚拟IP地址172.17.0.3:8080 这显然是无法请求到的，需要手工声明 Apollo Meta Server 的服务地址 添加程序启动参数 再次运行后报错消失","tags":["java","springboot"],"categories":["日常问题解决"]},{"title":"数据库连接超时","path":"/2023/01/08/problem20230108/","content":"Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30013ms. 问题描述之前写好的监测程序跑着跑着就会报错，报错信息提示连接不可用，请求超时 但是该错误并不是一直显示，正常运行时偶尔会报错，然后过段时间又可以正常运行 解决思路猜测是数据库连接堵塞的问题，在application.yml中配置数据库连接池，增加最大连接数： 12345678910111213141516171819spring: datasource: # 连接池 hikari: #连接池名 pool-name: GISMonitorHikariCP #最小空闲连接数 minimum-idle: 10 # 空闲连接存活最大时间，默认600000（10分钟） idle-timeout: 180000 # 连接池最大连接数，默认是10 maximum-pool-size: 64 # 此属性控制从池返回的连接的默认自动提交行为,默认值：true auto-commit: true # 此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟 max-lifetime: 1800000 # 数据库连接超时时间,默认30秒，即30000 connection-timeout: 30000 connection-test-query: SELECT 1 但是运行了一段时间还是报错了，重新看了下报错，发现提示连接数过多 修改mysql的my.ini配置文件，设置最大连接数 重启mysql后继续运行监测程序，运行两天未见报错 通过SQL语句监测线程数目，数目在设置范围内正常波动","tags":["java","springboot"],"categories":["日常问题解决"]},{"title":"统计和规定时间的交集","path":"/2022/11/26/problem20221205/","content":"统计跨天时间段和夜间时间段（01:00 ~ 06:00）的交集 需求定义最近写代码遇到一个需求 夜间停留时间统计用户的时间段是%Y-%m-%d %H:%M:%S形式，需要统计这段时间和01:00 ~ 06:00的交集，即，假设用户时间段是2022-02-02 05:30 ~ 2022-02-02 06:30，那么交集即为30min。如果用户时间段是2022-02-02 05:30 ~ 2022-02-03 06:30，那么交集即为5h30min。 上网搜了一下，大部分的方案都是给定了具体日期，例如求2022-02-02 05:30 ~ 2022-02-02 06:30和2022-02-02 06:00 ~ 2022-02-02 08:30这两个时间段的交集，而没有忽略日期，单纯考虑%H:%M:%S的交集统计。 解决思路思路其实也很简单，就是统计每天和01:00 ~ 06:00的交集，例如2022-02-02 05:30 ~ 2022-02-03 06:30，那就是先统计2022-02-02和01:00 ~ 06:00的交集，再统计2022-02-03和01:00 ~ 06:00的交集，最终结果以秒数统计。 解决代码123456789101112131415161718192021222324252627282930313233# 统计和规定时间的交集def timeIntersection(time2JudgeStart,time2JudgeEnd,ruleHourStart,ruleHourEnd): &#x27;&#x27;&#x27; Parameters: time2JudgeStart - 用户时间段开始时间 - string &#x27;%Y-%m-%d %H:%M:%S&#x27; time2JudgeEnd - 用户时间段停止时间 - string &#x27;%Y-%m-%d %H:%M:%S&#x27; ruleHourStart - 求交集的规定开始时间(小时) - int ruleHourStart - 求交集的规定停止时间(小时) - int Returns: intersectionSum - 交集统计时间(秒) - int &#x27;&#x27;&#x27; time2JudgeStart = datetime.strptime(time2JudgeStart, &#x27;%Y-%m-%d %H:%M:%S&#x27;) time2JudgeEnd = datetime.strptime(time2JudgeEnd, &#x27;%Y-%m-%d %H:%M:%S&#x27;) startDay = time2JudgeStart.date() endDay = time2JudgeEnd.date() diffDays = (endDay - startDay).days intersectionSum = 0 #分别计算每天的交集 for i in range(diffDays+1): timeDay = startDay+timedelta(days=i) timeStart = datetime(timeDay.year, timeDay.month, timeDay.day, ruleHourStart, 0) timeEnd = datetime(timeDay.year, timeDay.month, timeDay.day, ruleHourEnd, 0) if(time2JudgeEnd &lt;= timeStart):break if(time2JudgeStart &gt;= timeEnd):continue if(time2JudgeEnd &lt; timeEnd): if(time2JudgeStart &lt; timeStart):intersectionSum = intersectionSum + (time2JudgeEnd-timeStart).total_seconds() else:intersectionSum = intersectionSum + (time2JudgeEnd-time2JudgeStart).total_seconds() if(time2JudgeEnd &gt; timeEnd): if(time2JudgeStart &lt; timeStart):intersectionSum = intersectionSum + (timeEnd-timeStart).total_seconds() else:intersectionSum = intersectionSum + (timeEnd-time2JudgeStart).total_seconds() return intersectionSum","tags":["python"],"categories":["日常问题解决"]},{"title":"MarkDown格式测试文档","path":"/2022/11/25/MarkDownTest/","content":"测试了各种MarkDown语法，便于之后进行查阅 标题：我展示的是一级标题我展示的是二级标题一级标题二级标题三级标题四级标题五级标题六级标题字体：Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 斜体文本斜体文本粗体文本粗体文本粗斜体文本 建立分割线： 删除线：RUNOOB.COMGOOGLE.COMBAIDU.COM 下划线：带下划线文本 脚注：目前的脚注会导致页面跳转创建脚注格式类似这样 ^RUNOOB。 生成一个脚注1[^footnote] [^footnote]: 这里是 脚注 的 内容.生成一个脚注2^foot. 区块： 区块引用最外层 第一层嵌套 第二层嵌套 区块中使用列表 第一项 第二项 第一项 第二项 第三项 列表中使用区块 第一项 菜鸟教程学的不仅是技术更是梦想 第二项 代码：printf() 函数代码区块使用 4 个空格或者一个制表符（Tab 键）。 int main (void) &#123; return 0; &#125; 你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）： 123$(document).ready(function () &#123; alert(&#x27;RUNOOB&#x27;);&#125;); 链接：这是一个链接 菜鸟教程 这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址） 图片：Markdown 图片语法格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 标签。 表格：Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 表头 表头 单元格 单元格 单元格 单元格 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 左对齐 居中对齐 右对齐 左对齐 1 2 3 4 5 6 7 8 1-8 6 1 2 3 4 5 7 8 6 1-7 2 1 7 3 4 5 8 2 6 1–6 6 1 7 3 4 5 8 2 6 1–5 1 5 7 3 4 1 8 2 6 1–4 3 5 7 4 3 1 8 2 6 1–3 3 5 7 4 3 1 8 2 6 1–2 1 7 5 4 3 1 8 2 6 高级技巧：不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 使用 Ctrl+Alt+Del 重启电脑 这一行需要居中 我是黑体字 我是宋体字 颜色 执行命令：gem install jekyll下一步：jekyll s接下来：jekyll serve 使用如下代码使得所有表格居中： 12345&lt;style&gt;table &#123;margin: auto;&#125;&lt;/style&gt; 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： 1234567$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$$ $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\\\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\\\ \\end{vmatrix} $$"},{"path":"/about/index.html","content":"人的正确思想是从哪里来的？是从天上掉下来的吗？不是。是自己头脑里固有的吗？不是。 人的正确思想，只能从社会实践中来，只能从社会的生产斗争、阶级斗争和科学实验这三项实践中来。人们的社会存在，决定人们的思想。而代表先进阶级的正确思想，一旦被群众掌握，就会变成改造社会、改造世界的物质力量。个人介绍教育经历一个在学的GISer会一些C++、Python、JAVA，泛而不精2021 年 ~ 至今武汉大学 遥感信息工程学院 地图学与地理信息系统 硕士在读2017 年 ~ 2021年武汉大学 遥感信息工程学院 遥感科学与技术 本科毕业"},{"title":"常用网址","path":"/notes/index.html","content":"云平台汇总 高德开放平台https://console.amap.com/dev/index阿里云平台https://home.console.aliyun.com/腾讯云平台https://console.cloud.tencent.com/又拍云平台https://console.upyun.com/dashboard/LeanCloud国际版https://console.leancloud.app/appsvercel服务器https://vercel.com/dashboard 常用网址 Stellar&nbsp;-&nbsp;每个人的独立博客https://xaoxuu.com/wiki/stellar/Maven仓库https://mvnrepository.com/一网一匠网站索引https://ywyj.cn/阿里巴巴矢量图标库https://www.iconfont.cn/Z-Libaryhttps://zlib.cydiar.com/ 工作相关 代码随想录https://www.programmercarl.com/牛客网https://www.nowcoder.com/"},{"title":"blobs表情包索引","path":"/notes/QuickAccess/blobsIndexs.html","content":"使用格式： pnggif 表情 索引 表情 索引 blobamused blobcatflower blobangery blobcatgay blobangry blobcatgooglycry blobangrypuff blobcatgooglytrash blobaww blobcatheadphones blobbanhammerr blobcatheart blobbroken blobcatheartpride blobcat0_0 blobcathighfive blobcatscared blobcatkissheart blobcatangry blobcatlove blobcatblush blobcatmelt blobcatbox blobcatmeltthumb blobcatcaged blobcatneutral blobcatcoffee blobcatnomblobcat blobcatcomftears blobcatnotlikethis blobcatcomfy blobcatopenmouth blobcatcomfysweat blobcatpeek2 blobcatcry blobcatpeekaboo blobcatdead blobcatphoto blobcatdied blobcatpolice blobcatdisturbed blobcatpresentred blobcatfacepalm blobcatread blobcatfearful blobcatsadreach blobcatfingerguns blobcatsaitama blobcatflip 表情 索引 ablobangel ablobcatattentionreverse ablobcatheart ablobcatheartbroken ablobcatrainbow ablobcatreachrev ablobcatwave blobcatalt"},{"title":"Docker常用命令查询","path":"/notes/QuickAccess/docker.html","content":"docker信息查询启动docker服务查看docker服务状态查看docker版本查看docker容器信息查看docker容器帮助 docker镜像管理查看本地镜像OPTIONS说明：-a ： 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；–digests ： 显示镜像的摘要信息；-f ： 显示满足条件的镜像；–format ： 指定返回值的模板文件；–no-trunc ： 显示完整的镜像信息；-q ： 只显示镜像ID。删除本地镜像OPTIONS说明：-f ： 强制删除；–no-prune ： 不移除该镜像的过程镜像，默认移除；标记本地镜像使用Dockerfile创建镜像OPTIONS说明：–build-arg&#x3D;[] ： 设置镜像创建时的变量；–cpu-shares ： 设置 cpu 使用权重；–cpu-period ： 限制 CPU CFS周期；–cpu-quota ： 限制 CPU CFS配额；–cpuset-cpus ： 指定使用的CPU id；–cpuset-mems ： 指定使用的内存 id；–disable-content-trust ： 忽略校验，默认开启；-f ： 指定要使用的Dockerfile路径；–force-rm ： 设置镜像过程中删除中间容器；–isolation ： 使用容器隔离技术；–label&#x3D;[] ： 设置镜像使用的元数据；-m ： 设置内存最大值；–memory-swap ： 设置Swap的最大值为内存+swap，”-1”表示不限swap；–no-cache ： 创建镜像的过程不使用缓存；–pull ： 尝试去更新镜像的新版本；–quiet, -q ： 安静模式，成功后只输出镜像 ID；–rm ： 设置镜像成功后删除中间容器；–shm-size ： 设置&#x2F;dev&#x2F;shm的大小，默认值是64M；–ulimit ： Ulimit配置。–squash ： 将 Dockerfile 中所有的操作压缩为一层。–tag, -t： 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。–network： 默认 default。在构建期间设置RUN指令的网络模式查看指定镜像创建历史OPTIONS说明：-H ： 以可读的格式打印镜像大小和日期，默认为true；–no-trunc ： 显示完整的提交记录；-q ： 仅列出提交记录ID。将指定镜像保存成tar归档文件OPTIONS说明：-o ： 输出到的文件。导入tar归档文件OPTIONS说明：–input , -i ： 指定导入的文件，代替 STDIN。–quiet , -q ： 精简输出信息。从归档文件中创建镜像OPTIONS说明：-c ： 应用docker 指令创建镜像；-m ： 提交时的说明文字； docker镜像仓库登录/登出OPTIONS说明：-u ： 登陆的用户名-p ： 登陆的密码拉取镜像OPTIONS说明：-a ： 拉取所有 tagged 镜像–disable-content-trust ： 忽略镜像的校验,默认开启上传镜像OPTIONS说明：–disable-content-trust ： 忽略镜像的校验,默认开启从DockerHub查找镜像OPTIONS说明：–automated ： 只列出 automated build类型的镜像；–no-trunc ： 显示完整的镜像描述；-f &lt;过滤条件&gt;:列出收藏数不小于指定值的镜像。 docker容器生命周期管理创建新容器创建但不启动创建并启动OPTIONS说明：-a stdin： 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；-d： 后台运行容器，并返回容器ID；-i： 以交互模式运行容器，通常与 -t 同时使用；-P： 随机端口映射，容器内部端口随机映射到主机的端口-p： 指定端口映射，格式为：主机(宿主)端口:容器端口-t： 为容器重新分配一个伪输入终端，通常与 -i 同时使用；–name&#x3D;”nginx-lb”： 为容器指定一个名称；–dns 8.8.8.8： 指定容器使用的DNS服务器，默认和宿主一致；–dns-search example.com： 指定容器DNS搜索域名，默认和宿主一致；-h “mars”： 指定容器的hostname；-e username&#x3D;”ritchie”： 设置环境变量；–env-file&#x3D;[]： 从指定文件读入环境变量；–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”： 绑定容器到指定CPU运行；-m ： 设置容器使用内存最大值；–net&#x3D;”bridge”： 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container： 四种类型；–link&#x3D;[]： 添加链接到另一个容器；–expose&#x3D;[]： 开放一个端口或一组端口；–volume , -v： 绑定一个卷start/stop/restart杀死容器OPTIONS说明：-s ： 向容器发送一个信号删除容器OPTIONS说明：-f ： 通过 SIGKILL 信号强制删除一个运行中的容器。-l ： 移除容器间的网络连接，而非容器本身。-v ： 删除与容器关联的卷。容器暂停与恢复在运行的容器中执行命令OPTIONS说明：-d ： 分离模式： 在后台运行-i ： 即使没有附加也保持STDIN 打开-t ： 分配一个伪终端删除容器OPTIONS说明：-f ： 通过 SIGKILL 信号强制删除一个运行中的容器。-l ： 移除容器间的网络连接，而非容器本身。-v ： 删除与容器关联的卷。 docker容器文件管理从容器创建一个新的镜像OPTIONS说明：-a ： 提交的镜像作者；-c ： 使用Dockerfile指令来创建镜像；-m ： 提交时的说明文字；-p ： 在commit时，将容器暂停。容器与主机之间数据拷贝从容器到主机从主机到容器OPTIONS说明：-L ： 保持源目标中的链接 检查容器里文件结构的更改 docker容器操作列出容器OPTIONS说明：-a ： 显示所有的容器，包括未运行的。-f ： 根据条件过滤显示的内容。–format ： 指定返回值的模板文件。-l ： 显示最近创建的容器。-n ： 列出最近创建的n个容器。–no-trunc ： 不截断输出。-q ： 静默模式，只显示容器编号。-s ： 显示总的文件大小。获取容器/镜像的元数据OPTIONS说明：-f ： 指定返回值的模板文件。-s ： 显示总的文件大小。–type ： 为指定类型返回JSON。查看容器中运行的进程信息连接到正在运行中的容器从服务器获取实时事件OPTIONS说明：-f ：根据条件过滤事件；–since ：从指定的时间戳后显示所有事件;–until ：流水时间显示到指定的时间为止；如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since&#x3D;”2016-07-01”。获取容器的日志OPTIONS说明：-f ： 跟踪日志输出–since ： 显示某个开始时间的所有日志-t ： 显示时间戳–tail ： 仅列出最新N条容器日志阻塞运行直到容器停止将文件系统作为一个tar归档文件导出到STDOUTOPTIONS说明：-o ： 将输入内容写到文件列出指定的容器的端口映射显示容器资源的使用情况OPTIONS说明：–all , -a ： 显示所有的容器，包括未运行的。–format ： 指定返回值的模板文件。–no-stream ： 展示当前状态就直接退出了，不再实时更新。–no-trunc ： 不截断输出。"},{"title":"连接数据库","path":"/wiki/GISMonitor/Connect2MySQL.html","content":"导入依赖本项目的数据均为结构化数据，采用MySQL数据库进行数据存储与管理。 在pom.xml中导入相应的依赖： 12345678910&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件新建resources/config/application.yml配置文件，写入数据库配置信息（test为样例数据库）： 12345678910spring: datasource: username: #数据库用户名 password: #数据库密码 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Drivermybatis: type-aliases-package: com.rsgis.bean #数据库对应的实体 mapper-locations: classpath:mapper/*.xml #在resource包下创建mapper文件夹，然后在其中创建xml文件 SpringBoot配置文件优先级jar包同一目录下的config文件夹内的配置文件jar包同一目录下的配置文件classpath下的config文件夹内的配置文件classpath下的配置文件优先级从上到下依次递减 mybatis使用mybatis的使用需要依次构建Bean层实体类、Mapper层访问数据库接口文件、数据库访问实现文件MySQLMapper.xml 构建实体类根据数据库中的对象来构建相应的实体，在pom.xml中引入Lombok来简化代码： 1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; Lombok常用注解@Setter: 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。@Getter: 使用方法同上，区别在于生成的是getter方法。@ToString: 注解在类，添加toString方法。@EqualsAndHashCode: 注解在类，生成hashCode和equals方法。@NoArgsConstructor: 注解在类，生成无参的构造方法。@RequiredArgsConstructor: 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。@AllArgsConstructor: 注解在类，生成包含类中所有字段的构造方法。@Data: 注解在类，生成setter&#x2F;getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。@Slf4j: 注解在类，生成log变量，严格意义来说是常量。private static final Logger log &#x3D; LoggerFactory.getLogger(UserController.class); 在bean层下新建ObjectBean类，依据数据库内字段进行构建，并配置注释： @Data、@NoArgsConstructor、@AllArgsConstructor 12345678910111213package com.rsgis.bean;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class ObjectBean &#123; private long object_ID; private String type;&#125; 构建访问接口文件在mapper层下新建MySQLMapper接口类，构建相应接口 123456789101112131415package com.rsgis.mapper;import com.rsgis.bean.ObjectBean;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;//这个注解表示该类为mybatis的mapper类//也可以在项目启动类中使用@MapperScan(&quot;com.rsgis.mapper&quot;)来扫描所有mapper接口@Mapper//将接口的实现类交给Spring进行管理@Repositorypublic interface MySQLMapper &#123; List&lt;ObjectBean&gt; getAllObject();&#125; 构建访问实现文件在resource/mapper/MySQLMapper.xml中实现接口对应的SQL语句，namespace要填写访问数据库接口类文件路径 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.rsgis.mapper.MySQLMapper&quot;&gt; &lt;select id=&quot;getAllObject&quot; resultType=&quot;com.rsgis.bean.ObjectBean&quot; useCache=&quot;true&quot;&gt; select * from objects &lt;/select&gt; &lt;update id=&quot;UpdateFunction&quot; parameterType=&quot;com.rsgis.bean.FunctionBean&quot;&gt; update functions set req_num = #&#123;req_num&#125; where function_ID = #&#123;function_ID&#125;; &lt;/update&gt;&lt;/mapper&gt; 测试连接在test/java/com/rsgis/GisMonitorApplicationTests内构造测试代码并输出结果 12345678910111213@SpringBootTestclass GisMonitorApplicationTests &#123; @Autowired private MySQLMapper mySQLMapper; @Test void contextLoads() &#123; List&lt;ObjectBean&gt; allObjects = mySQLMapper.getAllObject(); System.out.println(allObjects); &#125;&#125; 输出结果如下，数据库连接正常 Error：SQL语句提示“应为标记名称” 在写SQL语句时，发现 &lt; 号报错了，经查询发现是mybatis做了转义，对应表格如下： mybatis转义对应表 原始 转义 原始 转义 &lt; &amp;lt; &gt;&#x3D; &amp;gt;&#x3D; &lt;&#x3D; &amp;lt;&#x3D; &amp; &amp;amp; &gt; &amp;gt; ‘ &amp;apos; “ &amp;quot;"},{"title":"新建SpringBoot项目","path":"/wiki/GISMonitor/CreateSpringBoot.html","content":"新建项目通过IDEA新建SpringBoot项目，并勾选Spring Web 然后在resources文件夹下新建banner.txt，放入可爱的猫猫 1234 |\\__/,| (`\\ |_ _ |.--.) ) ( T ) /(((^_(((/(((_/ Error: 端口占用新建完成后运行，发现报错端口被占用 使用cmd命令查看被占用的端口 1netstat -ano | findstr 端口号 得到对应的进程号，通过任务管理器进行PID排序查找，发现居然是TIM？ 把TIM关了就可以正常运行了"},{"title":"CurlCmd","path":"/wiki/GISMonitor/CurlCmd.html","content":"请求参数对数字资产对象的监测通过Curl进行，其请求参数如下表所示： Parameters Interpretation -L 自动重定向，当前资源已经移至其他地址时，自动重定向到新的地址 -k 解除curl的安全认证（不解除有的服务就会报60错误） –connect-timeout [seconds] 设置最大连接时间（后接时间） -m&#x2F;–max-time [seconds] 设置最大操作总时间（后接时间） -w 按照后面的格式写出返回消息 time_namelookup DNS解析域名的时间 time_connect client和server端建立TCP连接的时间（包括解析域名的时间） time_starttransfer 从开始到server 响应第一个字节的时间，即发送请求和服务器响应的时间之和（包括前面2个时间） time_total 从开始到server发送完所有的响应数据，并关闭连接的时间（包括前面所有时间） speed_download 下载速度，单位byte&#x2F;s http_code 返回的HTTP状态码 size_download 返回内容大小，单位byte content_type 返回内容的格式 Request示例curl -L -k –connect-timeout 30 -m 60 -w “ ”%{time_namelookup}::%{time_connect}::%{time_starttransfer}::%{time_total}::%{speed_download}::%{http_code}::%{size_download}::%{content_type}” ” URL 返回说明返回内容格式Curl在不同环境下返回的格式不同： Windows环境：Windows环境下返回的内容最后一行即为上述请求参数的结果，以“::”分开。 Linux环境：Linux环境下返回内容的格式和Windows相同，但需注意的是Linux下输入命令和输出结果的每一行都会自动加上双引号，所以代码中Linux环境下输入命令的url前后都不需加双引号，否则协议会被视为http而导致命令无法执行；返回结果中由于最后一行是一个双引号，所以要取倒数第二行，同时倒数第二行也会自动加上双引号，要进行处理。 12345678910111213141516//输入命令处理if (this.osName.startsWith(&quot;Windows&quot;)) &#123; curlCmd = &quot;curl -L -k --connect-timeout &quot; + con_timeout + &quot; -m &quot; + ope_timeout + &quot; -w \\&quot;\\ \\&quot;%&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;::%&#123;http_code&#125;::%&#123;size_download&#125;::%&#123;content_type&#125;\\&quot;\\ \\&quot; \\&quot;&quot; + url + &quot;\\&quot;&quot;;&#125; else if ((this.osName.contains(&quot;Linux&quot;)) || (this.osName.contains(&quot;CentOS&quot;))) &#123; curlCmd = &quot;curl -L -k --connect-timeout &quot; + con_timeout + &quot; -m &quot; + ope_timeout + &quot; -w \\&quot;\\ \\&quot;%&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;::%&#123;http_code&#125;::%&#123;size_download&#125;::%&#123;content_type&#125;\\&quot;\\ \\&quot; &quot; + url;&#125;//返回结果处理if (this.osName.startsWith(&quot;Windows&quot;)) &#123; mess = response.get(size1 - 1);&#125; else if ((this.osName.contains(&quot;Linux&quot;)) || (osName.contains(&quot;CentOS&quot;))) &#123; String messT = response.get(size1 - 2); mess = messT.substring(1, messT.length() - 1);&#125; 返回内容处理由于使用curl工具时，命令行内显示的是inputstream，即命令执行的结果；同时命令还会产生错误流errorstream，显示每隔一段时间接受数据量、下载速度等内容，会不断生成。输出缓冲区的size有限，如果不及时处理这两个流，就会发生阻塞，失去响应，所以程序中另外开了一个线程去读取错误流，保证两个流都及时的被读取，防止发生阻塞。 1234567891011121314151617181920212223242526272829303132333435363738Process process = Runtime.getRuntime().exec(curlCmd);final InputStreamReader ir1 = new InputStreamReader(process.getInputStream(), &quot;GBK&quot;);final InputStreamReader ir2 = new InputStreamReader(process.getErrorStream(), &quot;GBK&quot;);BufferedReader br1 = new BufferedReader(ir1);String line = null;final List&lt;String&gt; response = new ArrayList&lt;String&gt;();final List&lt;String&gt; errs = new ArrayList&lt;String&gt;();//这里，如果无法正常curl，就会不断产生errorStream,因为输出缓冲区的size有限，如果不及时处理的话就会卡住，所以这里要同时处理errorStream;//但是如果能正常curl的话，如果不及时处理inputStream也会卡住；要及时读取那个不断生成的流Thread thread = new Thread(() -&gt; &#123; BufferedReader br2 = new BufferedReader(ir2); try &#123; String line2 = null; while ((line2 = br2.readLine()) != null) &#123; if (!&quot;&quot;.equals(line2)) &#123; errs.add(line2); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ir2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);thread.start();while ((line = br1.readLine()) != null) &#123; if (!&quot;&quot;.equals(line)) &#123; response.add(line); &#125;&#125;thread.join();int exitValue = process.waitFor();process.destroy();ir1.close(); 返回内容解析返回内容提取最后一行或倒数第二行，按照“::”进行分割，一般情况下得到8个字符串，但是当curl失败时，最后一个参数“content_type”的返回结果为空，则得到7个字符串，需要单独处理。 返回内容经分割后，分别对应请求中各参数的结果，其中分为2大类结果，分别是Curl成功和Curl不成功，对应命令的exitvalue为0和不为0。 具体分类见下表： cURL默认连接超时时间为20秒，即–connect-timeout参数设置为20秒以上时，仍然会以20秒作为最大连接时间。 当达到默认最大连接时间（即20秒）仍未连接上时会报7错误；当达到用户设定最大连接时间（只有设置小于20秒才有效）仍未连接上时会报28错误；当总操作时间达到用户设定最大操作时间（即-m参数）仍未完成时报28错误。 即7错误是达到默认连接超时时间的错误，28错误是达到用户设置超时时间的错误。 返回结果存储 Database Field Convertion Interpretation statusCode Original + Self-Define 按照上表方式处理 connect_time time_connect - time_namelookup 截止到建立完TCP连接的时间减去截止到解析完域名的时间 server_time time_starttransfer - time_connect 截止到Server响应第一个字节的时间减去截止到建立完TCP连接的时间 transfer_time time_total - time_starttransfer 总时间减去截止到server响应第一个字节的时间 total_time time_total 原内容 download_speed speed_download 原内容 data_byte size_download 原内容 content_type content_type 原内容 计算公式为： total_time&nbsp;=&nbsp;namelookup_time&nbsp;+&nbsp;connect_time&nbsp;+&nbsp;server_time&nbsp;+&nbsp;transfer_time 整个请求过程可以描述为： 域名解析&nbsp;→&nbsp;建立TCP连接（三次握手）&nbsp;→&nbsp;发送http的Get请求（请求能力文档或图层）&nbsp;→&nbsp;服务器处理&nbsp;→&nbsp;传输数据（能力文档或图层） 其中下载速度是指整个过程的平均下载速度，即download_speed&nbsp;=&nbsp;data_byte/total_time server_time实际上包含了发送Get请求的时间和服务器响应时间两个时间，无法分开。 需要注意的是，curl如果失败的话，返回的各种时间就会错乱，只有总时间始终有效，所以在数据库存储过程中，curl失败的情况只有total_time始终有效，其他时间可能记录为0。 详细代码CurlCmd.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package com.rsgis.utils;import com.rsgis.bean.CurlResponse;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.math.BigDecimal;import java.math.RoundingMode;import java.util.ArrayList;import java.util.List;import java.util.Objects;@NoArgsConstructor@AllArgsConstructorpublic class CurlCmd &#123; private String url; private int con_timeout; private int ope_timeout; private String osName; public CurlResponse doCurlCmd() throws InterruptedException &#123; try &#123; String curlCmd = null; //linux中在处理和输出字符串时会自动加双引号！！！ if (this.osName.startsWith(&quot;Windows&quot;)) &#123; curlCmd = &quot;curl -L -k --connect-timeout &quot; + con_timeout + &quot; -m &quot; + ope_timeout + &quot; -w \\&quot;\\ \\&quot;%&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;::%&#123;http_code&#125;::%&#123;size_download&#125;::%&#123;content_type&#125;\\&quot;\\ \\&quot; \\&quot;&quot; + url + &quot;\\&quot;&quot;; &#125; else if ((this.osName.contains(&quot;Linux&quot;)) || (this.osName.contains(&quot;CentOS&quot;))) &#123; curlCmd = &quot;curl -L -k --connect-timeout &quot; + con_timeout + &quot; -m &quot; + ope_timeout + &quot; -w \\&quot;\\ \\&quot;%&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;::%&#123;http_code&#125;::%&#123;size_download&#125;::%&#123;content_type&#125;\\&quot;\\ \\&quot; &quot; + url; &#125; Process process = Runtime.getRuntime().exec(curlCmd); final InputStreamReader ir1 = new InputStreamReader(process .getInputStream(), &quot;GBK&quot;); final InputStreamReader ir2 = new InputStreamReader(process .getErrorStream(), &quot;GBK&quot;); BufferedReader br1 = new BufferedReader(ir1); String line = null; final List&lt;String&gt; response = new ArrayList&lt;String&gt;(); final List&lt;String&gt; errs = new ArrayList&lt;String&gt;(); //这里，如果无法正常curl，就会不断产生errorStream,因为输出缓冲区的size有限，如果不及时处理的话就会卡住，所以这里要同时处理errorStream; //但是如果能正常curl的话，如果不及时处理inputStream也会卡住；要及时读取那个不断生成的流 Thread thread = new Thread(() -&gt; &#123; BufferedReader br2 = new BufferedReader(ir2); try &#123; String line2 = null; while ((line2 = br2.readLine()) != null) &#123; if (!&quot;&quot;.equals(line2)) &#123; errs.add(line2); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ir2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); while ((line = br1.readLine()) != null) &#123; if (!&quot;&quot;.equals(line)) &#123; response.add(line); &#125; &#125; thread.join(); int exitValue = process.waitFor(); process.destroy(); ir1.close(); return parseMessage(response, exitValue); &#125; catch (IOException e) &#123; System.out.println(&quot;IOException &quot; + e.getMessage()); return null; &#125; &#125; private CurlResponse parseMessage(List&lt;String&gt; response, int exitValue) &#123; int size1 = response.size(); CurlResponse cr = new CurlResponse(); if (size1 == 0) &#123; cr.setTime_connect(0); cr.setTime_server(0); cr.setTime_transfer(0); cr.setTime_total(0); cr.setData_size(0); cr.setDownload_speed(0); cr.setStatusCode(700); cr.setContentType(&quot;&quot;); return cr; &#125; else &#123; String mess = null; if (this.osName.startsWith(&quot;Windows&quot;)) &#123; mess = response.get(size1 - 1); &#125; else if ((this.osName.contains(&quot;Linux&quot;)) || (osName.contains(&quot;CentOS&quot;))) &#123; String messT = response.get(size1 - 2); mess = messT.substring(1, messT.length() - 1); &#125; assert mess != null; String[] message = mess.split(&quot;::&quot;); String type = null; if (message.length == 8) &#123; type = message[7].toLowerCase(); &#125; else &#123; type = &quot;&quot;; &#125; boolean valid = false; if (exitValue == 0) &#123; valid = ContentValid(response,type);//判断返回内容是否有效 &#125; float time0 = Float.parseFloat(message[0]); float time1 = Float.parseFloat(message[1]); float time2 = Float.parseFloat(message[2]); float time3 = Float.parseFloat(message[3]); int code = Integer.parseInt(message[5]); String data_type = type; float connect, server, tran, total, speed; float result_speed, result_connect, result_server, result_tran, result_total; if (exitValue == 0) &#123; connect = time1 - time0; server = time2 - time1; tran = time3 - time2; &#125; else &#123; connect = 0; server = 0; tran = 0; &#125; total = time3; speed = Float.parseFloat(message[4]); BigDecimal bg1 = new BigDecimal(speed); BigDecimal bg2 = new BigDecimal(connect); BigDecimal bg3 = new BigDecimal(server); BigDecimal bg4 = new BigDecimal(tran); BigDecimal bg5 = new BigDecimal(total); result_speed = bg1.setScale(3, RoundingMode.HALF_UP).floatValue(); result_connect = bg2.setScale(3, RoundingMode.HALF_UP).floatValue(); result_server = bg3.setScale(3, RoundingMode.HALF_UP).floatValue(); result_tran = bg4.setScale(3, RoundingMode.HALF_UP).floatValue(); result_total = bg5.setScale(3, RoundingMode.HALF_UP).floatValue(); cr.setContentType(data_type); cr.setTime_connect(result_connect); cr.setTime_transfer(result_tran); cr.setTime_server(result_server); cr.setTime_total(result_total); cr.setData_size(Integer.parseInt(message[6])); cr.setDownload_speed(result_speed); if (exitValue != 0)//IOException, curl failed &#123; cr.setStatusCode(exitValue); &#125; else &#123;//curl succes if ((code == 200) &amp;&amp; (!valid))//invalid services or layers &#123; cr.setStatusCode(600);;//self-defined statusCode &#125; else//valid services or layers &#123; cr.setStatusCode(code); &#125; &#125; return cr; &#125; &#125;&#125;"},{"title":"FGDCChecker","path":"/wiki/GISMonitor/FGDCChecker.html","content":"FGDC介绍FGDC,即美国联邦地理数据委员会（FederalGeodata Commission），其提供了服务状态检查器（Service Status Checker ，SSC）来验证、测试和评分地理空间 Web 服务。 在这里，我们使用liveTest API来测试我们监测的服务状态，作为综合评分的参考。 Supported API Method: GETRequest Format: https://statuschecker.fgdc.gov/api/v2/liveTest?auth=&amp;type&#x3D;&amp;url&#x3D;&amp;[other &#x3D; pairs] 结果解析设置返回格式为XML，使用jdom2进行解析，在pom.xml中引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.jdom&lt;/groupId&gt; &lt;artifactId&gt;jdom2&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt; JDOM操作xml常用类Document：表示整个xml文档，是一个树形结构Eelment：表示一个xml的元素，提供方法操作其子元素，如文本，属性和名称空间等Attribute：表示元素包含的属性Text：表示xml文本信息XMLOutputter：xml输出流，底层是通过JDK中流实现Format：提供xml文件输出的编码、样式和排版等设置 一个示例返回文档如下： 可以发现，我们关心的属性位于response/service/summary/scoredTest/performance下，相应的解析代码如下： 1234567891011121314SAXBuilder parser = new SAXBuilder();Document FGDCDoc = parser.build(FGDCRequestURL);Element RootEle = FGDCDoc.getRootElement();Element Service = RootEle.getChild(&quot;service&quot;, RootEle.getNamespace());Element summary = Service.getChild(&quot;summary&quot;, RootEle.getNamespace());Element scoredTest = summary.getChild(&quot;scoredTest&quot;, RootEle.getNamespace());List&lt;Element&gt; performance = scoredTest.getChildren(&quot;performance&quot;, RootEle.getNamespace());fp.setFGDC_time(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime()));Element currentScore = performance.get(1);String scoreString = currentScore.getValue();fp.setFGDC_score(Float.parseFloat(scoreString));Element currentSpeed = performance.get(0);String currentSpeedString = currentSpeed.getValue();fp.setFGDC_speed(Float.parseFloat(currentSpeedString)); 其中，FGDC_score为FGDC基于web服务 速度性能 和 响应正确性 所给出的综合打分（百分制），FGDC_speed为测试所用耗时（秒） 同时，FGDC还进行了一系列测试，将测试成功与否存于路径response/service/test下，解析代码如下： 1234567891011121314151617181920//&lt;!-- 0 = Failed, 1 = Success, 2 = IP banned - Not tested and -99.99 = Not tested --&gt;List&lt;Element&gt; testList = Service.getChildren(&quot;test&quot;, RootEle.getNamespace());for (Element element : testList) &#123; if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;httpServer&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setHttpServerSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;getCapabilities&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGetCapabilitiesSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;generatedGetCapabilities&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGeneratedGetCapabilitiesSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;getMap&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGetMapSuccess(Float.parseFloat(output.getValue())); &#125;&#125; 详细代码FGDCChecker.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@NoArgsConstructor@AllArgsConstructorpublic class FGDCChecker &#123; private String URL; public FGDCPerformance GetFGDCPerformance()&#123; FGDCPerformance fp = new FGDCPerformance(); String FGDCRequestURL = &quot;https://statuschecker.fgdc.gov/api/v2/liveTest?auth=&#123;yourKey&#125;&amp;type=WMS&amp;url=&quot; + this.URL + &quot;&amp;formattype=XML&quot;; try &#123; SAXBuilder parser = new SAXBuilder(); Document FGDCDoc = parser.build(FGDCRequestURL); Element RootEle = FGDCDoc.getRootElement(); Element Service = RootEle.getChild(&quot;service&quot;, RootEle.getNamespace()); Element summary = Service.getChild(&quot;summary&quot;, RootEle.getNamespace()); Element scoredTest = summary.getChild(&quot;scoredTest&quot;, RootEle.getNamespace()); List&lt;Element&gt; performance = scoredTest.getChildren(&quot;performance&quot;, RootEle.getNamespace()); fp.setFGDC_time(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime())); Element currentScore = performance.get(1); String scoreString = currentScore.getValue(); fp.setFGDC_score(Float.parseFloat(scoreString)); Element currentSpeed = performance.get(0); String currentSpeedString = currentSpeed.getValue(); fp.setFGDC_speed(Float.parseFloat(currentSpeedString));// &lt;!-- 0 = Failed, 1 = Success, 2 = IP banned - Not tested and -99.99 = Not tested --&gt; List&lt;Element&gt; testList = Service.getChildren(&quot;test&quot;, RootEle.getNamespace()); for (Element element : testList) &#123; if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;httpServer&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setHttpServerSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;getCapabilities&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGetCapabilitiesSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;generatedGetCapabilities&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGeneratedGetCapabilitiesSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;getMap&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGetMapSuccess(Float.parseFloat(output.getValue())); &#125; &#125; return fp; &#125; catch (Exception e) &#123; fp.setFGDC_time(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime())); fp.setFGDC_score(-1); fp.setFGDC_speed(-1); fp.setHttpServerSuccess(-1); fp.setGetCapabilitiesSuccess(-1); fp.setGeneratedGetCapabilitiesSuccess(-1); fp.setGetMapSuccess(-1); return fp; &#125; &#125;&#125;"},{"title":"定时任务","path":"/wiki/GISMonitor/MonitorSchedule.html","content":"根据需要，新建MonitorSchedule类来实现监测服务的定时运行 基于注解（@Scheduled）基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响。 @EnableScheduling : 在配置类上使用，开启计划任务的支持 @Scheduled : 来声明这是一个任务，包括 cron，fixDelay，fixRate 等类型 定时调用监测服务12345678910111213141516171819@Service@EnableSchedulingpublic class MonitorSchedule &#123; @Value(&quot;$&#123;settings.monitor.startIndex&#125;&quot;) private int index; @Value(&quot;$&#123;settings.monitor.partition&#125;&quot;) private int partition; private String monitorIP; @Autowired private MonitorService monitorService; @Scheduled(fixedDelayString = &quot;$&#123;settings.monitor.fixedDelay:600000&#125;&quot;,initialDelay = 3000) public void FunctionTimerTask() &#123; String newIP = new GetMonitorIP().GetIP(); if(newIP!=null)&#123;monitorIP = newIP;&#125; monitorService.FunctionMonitor(index,monitorIP); index=(index+1)%partition; &#125;&#125; @Scheduled - CronScheduled注解类源码1234567891011121314151617181920212223242526272829303132package org.springframework.scheduling.annotation; import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; @Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(Schedules.class)public @interface Scheduled &#123; String CRON_DISABLED = &quot;-&quot;; String cron() default &quot;&quot;; String zone() default &quot;&quot;; long fixedDelay() default -1L; String fixedDelayString() default &quot;&quot;; long fixedRate() default -1L; String fixedRateString() default &quot;&quot;; long initialDelay() default -1L; String initialDelayString() default &quot;&quot;;&#125; cron 表达式语法：秒 分 小时 日 月 周 年 1@Scheduled(cron = &quot;0/5 * * * * ?&quot;) 说明 是否必填 允许填写的值 允许的通配符 秒 是 0-59 , - * &#x2F; 分 是 0-59 , - * &#x2F; 小时 是 0-23 , - * &#x2F; 日 是 1-31 , - * ? &#x2F; L W 月 是 1-12 or JAN-DEC , - * &#x2F; 周 是 1-7 or MON-SUN , - * ? &#x2F; L # 年 否 empty 或 1970-2099 , - * &#x2F; 通配符含义, : 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发- : 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发* : 表示所有值. 例如:在分的字段上设置,表示每一分钟都会触发&#x2F; : 用于递增触发。如在秒上面设置”5&#x2F;15” 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置’1&#x2F;3’所示每月1号开始，每隔三天触发一次L : 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年), 在周字段上表示星期天，相当于”7”或”SUN”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期六”W : 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发，如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“).LW : 表示在本月的最后一个工作日触发# : 表示每月的第几个周几，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”6#5”,正好第五周没有周六，则不会触发该配置 @Scheduled - Zone时区，接收一个 java.util.TimeZone#ID 。cron表达式会基于该时区解析，默认是一个空字符串，即取服务器所在地的时区。 1@Scheduled(cron =&quot;0 0 14 * * *&quot;, zone =&quot;GMT-5&quot;) @Scheduled - fixedDelay上一次 执行完毕 时间点之后多长时间再执行: 1@Scheduled(fixedDelay = 5000) //上一次执行完毕时间点之后5秒再执行 @Scheduled - fixedDelayString与fixedDelay意思相同，只是使用字符串的形式，支持占位符： 123@Scheduled(fixedDelayString = &quot;5000&quot;) //上一次执行完毕时间点之后5秒再执行//占位符@Scheduled(fixedDelayString = &quot;$&#123;settings.monitor.fixedDelay:5000&#125;&quot;) //根据配置文件设置间隔，默认上一次执行完毕时间点之后5秒再执行 @Scheduled - fixedRate上一次 开始执行 时间点之后多长时间再执行： 1@Scheduled(fixedRate = 5000) //上一次开始执行时间点之后5秒再执行 @Scheduled - fixedRateString与fixedRate意思相同，只是使用字符串的形式，支持占位符： 123@Scheduled(fixedRateString = &quot;5000&quot;) //上一次开始执行时间点之后5秒再执行//占位符@Scheduled(fixedRateString = &quot;$&#123;settings.monitor.fixedRate:5000&#125;&quot;) //根据配置文件设置间隔，默认上一次开始执行时间点之后5秒再执行 @Scheduled - initialDelay 第一次 延迟多长时间后再执行： 1@Scheduled(initialDelay=1000, fixedRate=5000) //第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 @Scheduled - initialDelayString与initialDelay意思相同，只是使用字符串的形式，支持占位符: 1@Scheduled(initialDelay=&quot;$&#123;settings.monitor.initialDelay:1000&#125;&quot;, fixedRate=5000) ////根据配置文件设置间隔，默认第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次"},{"title":"监测服务","path":"/wiki/GISMonitor/MonitorService.html","content":"之前已经完成了Curl监测与FGDC检查两大工具类的构建，接下来将构建监测服务类，分为监测服务接口类、监测服务实现类与异步监测服务类 整个监测过程可以描述为： 获取待检测对象&nbsp;→&nbsp;多线程并行化监测&nbsp;→&nbsp;监测结果入库 线程池配置详细代码123456789101112131415161718192021222324@Configuration@EnableAsyncpublic class AsyncConfiguration &#123; @Bean(&quot;async&quot;) public Executor asyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 核心线程数：线程池创建时候初始化的线程数 executor.setCorePoolSize(32); // 最大线程数：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程 executor.setMaxPoolSize(64); // 缓冲队列：用来缓冲执行任务的队列 executor.setQueueCapacity(512); // 允许线程的空闲时间60秒：当超过了核心线程之外的线程在空闲时间到达之后会被销毁 executor.setKeepAliveSeconds(60); // 线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池 executor.setThreadNamePrefix(&quot;asyncExecutor-&quot;); // 缓冲队列满了之后的拒绝策略：由调用线程处理（一般是主线程） executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; &#125;&#125; SpringBoot使用的多线程方式非常简单，在需要异步的方法上加@Async(&quot;线程池名称&quot;)注解 ThreadPoolExecutor的拒绝策略AbortPolicyThreadPoolExecutor中默认的拒绝策略为AbortPolicy：12345678public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125;即直接抛出异常，并不再执行任务 CallerRunsPolicy该策略会在任务被拒绝添加后，调用当前线程池的所在的线程去执行被拒绝的任务：12345678public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125;该策略会导致主线程堵塞 DiscardPolicy该策略会将拒绝的任务直接丢弃，同时不抛出异常：12345public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; DiscardOldestPolicy该策略会在出现拒绝添加的任务时，从任务队列总弹出最先加入的任务（即Oldest），空出一个位置，然后再次执行execute方法把任务加入队列：123456789public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; 监测服务接口类1234public interface MonitorService &#123; public List&lt;FunctionBean&gt; GetFunctionList(int index); public void FunctionMonitor(int index) throws InterruptedException;&#125; 监测服务实现类详细代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Servicepublic class MonitorServiceImpl implements MonitorService &#123; @Autowired private MySQLMapper mySQLMapper; @Autowired private MonitorAsyncServer monitorAsyncServer; @Override public List&lt;FunctionBean&gt; GetFunctionList(int index) &#123; try &#123; return mySQLMapper.GetFunctionList(index); &#125;catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; @Override public void FunctionMonitor(int index) throws InterruptedException &#123; String monitorIP = new GetMonitorIP().GetIP();//获取监测点IP String osName = System.getProperties().getProperty(&quot;os.name&quot;);//获取监测点操作系统名 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;); Calendar cal = Calendar.getInstance(); List&lt;FunctionBean&gt; functionList = GetFunctionList(index);//获取待检测对象列表 CountDownLatch countDownLatch = new CountDownLatch(functionList.size()); System.out.println(&quot; ----------------------------------------------------------- &quot; + &quot;FunctionMonitor StartTime : &quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime())+ &quot; ( &quot;+monitorIP+&quot; - &quot;+osName+&quot; )&quot;); System.out.println(&quot;Monitor index-Size : &quot; +index+&quot; - &quot;+functionList.size()); for (FunctionBean function : functionList) &#123; monitorAsyncServer.FunctionMonitor(countDownLatch, monitorIP, osName,function); &#125; try &#123; countDownLatch.await(settingProperties.getMonitor().getCountDownLatchTimeout(), TimeUnit.MINUTES); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;Exception: await interrupted exception&quot;); &#125; finally &#123; System.out.println(&quot;countDownLatch: &quot; + countDownLatch.getCount()+&quot; (should be 0)&quot;); &#125; System.out.println(&quot;Monitor Finish at &quot;+new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime())); &#125;&#125; 在监测服务实现类中调用异步检测服务类MonitorAsyncServer实现对象的多线程异步监测。 为保证所有线程运行完后再执行下一步，加入CountDownLatch使代码修改为阻塞式： countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。 异步检测服务类在方法前加上注释 @Async(&quot;async&quot;) 声明此方法可使用多线程 详细代码1234567891011121314151617181920212223242526272829303132@Servicepublic class MonitorAsyncServer &#123; @Autowired MySQLMapper mySQLMapper; @Autowired private SettingProperties settingProperties; @Async(&quot;async&quot;) public void FunctionMonitor(CountDownLatch countDownLatch, String ip, String osName, FunctionBean function) &#123; //FGDC监测 FGDCPerformance fp = new FGDCChecker(function.getFunction_URL()).GetFGDCPerformance(); //Curl监测 CurlCmd cc = new CurlCmd(function.getFunction_URL(), function.getFunction_type(),function.getObject_type(), settingProperties.getCurl().getConnectionTimeOut(),settingProperties.getCurl().getOperationTimeOut(),osName); try &#123; CurlResponse cr = cc.doCurlCmd(); //处理并入库 UpdateFunction(function); AddFunctionPerformanceHistory(ip,function,fp,cr); //System.out.println(&quot;线程池&quot; + Thread.currentThread().getName()+&quot; - &quot;+countDownLatch.getCount()); countDownLatch.countDown(); &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); countDownLatch.countDown(); &#125; &#125;&#125; 多线程监测测试结果："},{"title":"配置文件读取","path":"/wiki/GISMonitor/SettingProperties.html","content":"Spring Boot读取配置文件常用方式@Value方式获取1234567//org.springframework.beans.factory.annotation.Value@Value($&#123;配置项key:默认值&#125;)private String configValue;//for example@Value(&quot;$&#123;value.request.timeout:20&#125;&quot;)private int timeOut; Environment对象获取1234567//org.springframework.core.env.Environment@Autowiredprivate Environment environment;//for exampleenvironment.getProperty(&quot;value.request.timeout&quot;) @ConfigurationProperties方式获取在application.yml中： 12345settings: name: ove curl: ConnectionTimeOut: 30 OperationTimeOut: 60 则对应的配置类为： 12345678910111213141516171819import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Data@Component@ConfigurationProperties(value = &quot;settings&quot;)public class SettingProperties &#123; private String name; private Curl curl; @Data public static class Curl &#123; private int ConnectionTimeOut; private int OperationTimeOut; &#125;&#125; 注意事项@ConfigurationProperties(value &#x3D; “settings”) 表示配置文件里属性的前缀是 settings配置类上记得加上 @Data 和 @Component 注解（或者在启动类上加上 @EnableConfigurationProperties(value &#x3D; AppProperties.class) ）如果有内部类对象，记得加上 @Data ，不然无法映射数据 使用方法： 12@Autowiredprivate SettingProperties settingProperties; @PropertySource方式获取有时候我们会有一些特殊意义的配置，会 单独 用一个配置文件存储，比如数据库配置连接参数(在application.yml同级目录新建一个配置文件) 则对应的配置类为： 12345678910@Data@Component@ConfigurationProperties(value = &quot;others&quot;)@PropertySource(value = &quot;classpath:others.properties&quot;, encoding = &quot;UTF-8&quot;, ignoreResourceNotFound = true)public class OtherSettingProperties &#123; private String userName; private String userAge;&#125; 注意事项@ConfigurationProperties(value &#x3D; “others”) 表示配置文件里属性的前缀是 others@PropertySource 中 value 属性表示指定配置文件的路径，encoding 属性表示指定的是读取配置文件时的编码，记得和文件 alian.properties 的编码保持一致，ignoreResourceNotFound 属性值为true时没找到指定配置文件的时候不报错配置类上记得加上 @Component 注解.yml 格式不支持 @PlaceSource 注解导入配置 使用方法： 12@Autowiredprivate OtherSettingProperties otherSettingProperties;"},{"title":"项目简介","path":"/wiki/GISMonitor/index.html","content":"数字资产对象定义本项目监测的数字资产对象包含：满足OGC标准的网络服务，包括WMS、WFS、WCS、WMTS、CSW等；视频；论文数据；计算机资源状态 项目需求原先已开发完成OGC网络服务的检测组件，但原始代码较为混乱，逻辑不够清晰，同时不能满足为前端提供接口的需求，故基于SpringBoot对原项目进行重构"}]