[{"title":"MarkDown格式测试文档","path":"/2022/11/25/MarkDownTest/","content":"测试了各种MarkDown语法，便于之后进行查阅 标题：我展示的是一级标题我展示的是二级标题一级标题二级标题三级标题四级标题五级标题六级标题字体：Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 斜体文本斜体文本粗体文本粗体文本粗斜体文本 建立分割线： 删除线：RUNOOB.COMGOOGLE.COMBAIDU.COM 下划线：带下划线文本 脚注：目前的脚注会导致页面跳转创建脚注格式类似这样 ^RUNOOB。 生成一个脚注1[^footnote] [^footnote]: 这里是 脚注 的 内容.生成一个脚注2^foot. 区块： 区块引用最外层 第一层嵌套 第二层嵌套 区块中使用列表 第一项 第二项 第一项 第二项 第三项 列表中使用区块 第一项 菜鸟教程学的不仅是技术更是梦想 第二项 代码：printf() 函数代码区块使用 4 个空格或者一个制表符（Tab 键）。 int main (void) &#123; return 0; &#125; 你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）： 123$(document).ready(function () &#123; alert(&#x27;RUNOOB&#x27;);&#125;); 链接：这是一个链接 菜鸟教程 这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址） 图片：Markdown 图片语法格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 标签。 表格：Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 表头 表头 单元格 单元格 单元格 单元格 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 左对齐 居中对齐 右对齐 左对齐 1 2 3 4 5 6 7 8 1-8 6 1 2 3 4 5 7 8 6 1-7 2 1 7 3 4 5 8 2 6 1–6 6 1 7 3 4 5 8 2 6 1–5 1 5 7 3 4 1 8 2 6 1–4 3 5 7 4 3 1 8 2 6 1–3 3 5 7 4 3 1 8 2 6 1–2 1 7 5 4 3 1 8 2 6 高级技巧：不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 使用 Ctrl+Alt+Del 重启电脑 这一行需要居中 我是黑体字 我是宋体字 颜色 执行命令：gem install jekyll下一步：jekyll s接下来：jekyll serve 使用如下代码使得所有表格居中： 12345&lt;style&gt;table &#123;margin: auto;&#125;&lt;/style&gt; 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： 1234567$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$$ $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\\\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\\\ \\end{vmatrix} $$"},{"path":"/about/index.html","content":"人的正确思想是从哪里来的？是从天上掉下来的吗？不是。是自己头脑里固有的吗？不是。 人的正确思想，只能从社会实践中来，只能从社会的生产斗争、阶级斗争和科学实验这三项实践中来。人们的社会存在，决定人们的思想。而代表先进阶级的正确思想，一旦被群众掌握，就会变成改造社会、改造世界的物质力量。个人介绍教育经历一个在学的GISer会一些C++、Python、JAVA，泛而不精2021 年 ~ 至今武汉大学 遥感信息工程学院 地图学与地理信息系统 硕士在读2017 年 ~ 2021年武汉大学 遥感信息工程学院 遥感科学与技术 本科毕业"},{"title":"常用网址","path":"/notes/index.html","content":"云平台汇总 高德开放平台https://console.amap.com/dev/index阿里云平台https://home.console.aliyun.com/腾讯云平台https://console.cloud.tencent.com/又拍云平台https://console.upyun.com/dashboard/LeanCloud国际版https://console.leancloud.app/appsvercel服务器https://vercel.com/dashboard 常用网址 Stellar&nbsp;-&nbsp;每个人的独立博客https://xaoxuu.com/wiki/stellar/Maven仓库https://mvnrepository.com/阿里巴巴矢量图标库https://www.iconfont.cn/ 工作相关 代码随想录https://www.programmercarl.com/牛客网https://www.nowcoder.com/"},{"title":"blobs表情包索引","path":"/notes/problems_slove/blobsIndexs.html","content":"pnggif 表情 索引 表情 索引 blobamused blobcatflower blobangery blobcatgay blobangry blobcatgooglycry blobangrypuff blobcatgooglytrash blobaww blobcatheadphones blobbanhammerr blobcatheart blobbroken blobcatheartpride blobcat0_0 blobcathighfive blobcatscared blobcatkissheart blobcatangry blobcatlove blobcatblush blobcatmelt blobcatbox blobcatmeltthumb blobcatcaged blobcatneutral blobcatcoffee blobcatnomblobcat blobcatcomftears blobcatnotlikethis blobcatcomfy blobcatopenmouth blobcatcomfysweat blobcatpeek2 blobcatcry blobcatpeekaboo blobcatdead blobcatphoto blobcatdied blobcatpolice blobcatdisturbed blobcatpresentred blobcatfacepalm blobcatread blobcatfearful blobcatsadreach blobcatfingerguns blobcatsaitama blobcatflip 表情 索引 ablobangel ablobcatattentionreverse ablobcatheart ablobcatheartbroken ablobcatrainbow ablobcatreachrev ablobcatwave blobcatalt"},{"title":"统计和规定时间的交集","path":"/notes/problems_slove/problem20221205.html","content":"需求定义最近写代码遇到一个需求 夜间停留时间统计用户的时间段是%Y-%m-%d %H:%M:%S形式，需要统计这段时间和01:00 ~ 06:00的交集，即，假设用户时间段是2022-02-02 05:30 ~ 2022-02-02 06:30，那么交集即为30min。如果用户时间段是2022-02-02 05:30 ~ 2022-02-03 06:30，那么交集即为5h30min。 上网搜了一下，大部分的方案都是给定了具体日期，例如求2022-02-02 05:30 ~ 2022-02-02 06:30和2022-02-02 06:00 ~ 2022-02-02 08:30这两个时间段的交集，而没有忽略日期，单纯考虑%H:%M:%S的交集统计。 解决思路思路其实也很简单，就是统计每天和01:00 ~ 06:00的交集，例如2022-02-02 05:30 ~ 2022-02-03 06:30，那就是先统计2022-02-02和01:00 ~ 06:00的交集，再统计2022-02-03和01:00 ~ 06:00的交集，最终结果以秒数统计。 解决代码123456789101112131415161718192021222324252627282930313233# 统计和规定时间的交集def timeIntersection(time2JudgeStart,time2JudgeEnd,ruleHourStart,ruleHourEnd): &#x27;&#x27;&#x27; Parameters: time2JudgeStart - 用户时间段开始时间 - string &#x27;%Y-%m-%d %H:%M:%S&#x27; time2JudgeEnd - 用户时间段停止时间 - string &#x27;%Y-%m-%d %H:%M:%S&#x27; ruleHourStart - 求交集的规定开始时间(小时) - int ruleHourStart - 求交集的规定停止时间(小时) - int Returns: intersectionSum - 交集统计时间(秒) - int &#x27;&#x27;&#x27; time2JudgeStart = datetime.strptime(time2JudgeStart, &#x27;%Y-%m-%d %H:%M:%S&#x27;) time2JudgeEnd = datetime.strptime(time2JudgeEnd, &#x27;%Y-%m-%d %H:%M:%S&#x27;) startDay = time2JudgeStart.date() endDay = time2JudgeEnd.date() diffDays = (endDay - startDay).days intersectionSum = 0 #分别计算每天的交集 for i in range(diffDays+1): timeDay = startDay+timedelta(days=i) timeStart = datetime(timeDay.year, timeDay.month, timeDay.day, ruleHourStart, 0) timeEnd = datetime(timeDay.year, timeDay.month, timeDay.day, ruleHourEnd, 0) if(time2JudgeEnd &lt;= timeStart):break if(time2JudgeStart &gt;= timeEnd):continue if(time2JudgeEnd &lt; timeEnd): if(time2JudgeStart &lt; timeStart):intersectionSum = intersectionSum + (time2JudgeEnd-timeStart).total_seconds() else:intersectionSum = intersectionSum + (time2JudgeEnd-time2JudgeStart).total_seconds() if(time2JudgeEnd &gt; timeEnd): if(time2JudgeStart &lt; timeStart):intersectionSum = intersectionSum + (timeEnd-timeStart).total_seconds() else:intersectionSum = intersectionSum + (timeEnd-time2JudgeStart).total_seconds() return intersectionSum"},{"title":"连接数据库","path":"/wiki/GISMonitor/Connect2MySQL.html","content":"导入依赖本项目的数据均为结构化数据，采用MySQL数据库进行数据存储与管理。 在pom.xml中导入相应的依赖： 12345678910&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件新建resources/config/application.yml配置文件，写入数据库配置信息（test为样例数据库）： 12345678910spring: datasource: username: #数据库用户名 password: #数据库密码 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Drivermybatis: type-aliases-package: com.rsgis.bean #数据库对应的实体 mapper-locations: classpath:mapper/*.xml #在resource包下创建mapper文件夹，然后在其中创建xml文件 SpringBoot配置文件优先级jar包同一目录下的config文件夹内的配置文件jar包同一目录下的配置文件classpath下的config文件夹内的配置文件classpath下的配置文件优先级从上到下依次递减 mybatis使用mybatis的使用需要依次构建Bean层实体类、Mapper层访问数据库接口文件、数据库访问实现文件MySQLMapper.xml 构建实体类根据数据库中的对象来构建相应的实体，在pom.xml中引入Lombok来简化代码： 1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; Lombok常用注解@Setter: 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。@Getter: 使用方法同上，区别在于生成的是getter方法。@ToString: 注解在类，添加toString方法。@EqualsAndHashCode: 注解在类，生成hashCode和equals方法。@NoArgsConstructor: 注解在类，生成无参的构造方法。@RequiredArgsConstructor: 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。@AllArgsConstructor: 注解在类，生成包含类中所有字段的构造方法。@Data: 注解在类，生成setter&#x2F;getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。@Slf4j: 注解在类，生成log变量，严格意义来说是常量。private static final Logger log &#x3D; LoggerFactory.getLogger(UserController.class); 在bean层下新建ObjectBean类，依据数据库内字段进行构建，并配置注释： @Data、@NoArgsConstructor、@AllArgsConstructor 12345678910111213package com.rsgis.bean;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class ObjectBean &#123; private long object_ID; private String type;&#125; 构建访问接口文件在mapper层下新建MySQLMapper接口类，构建相应接口 123456789101112131415package com.rsgis.mapper;import com.rsgis.bean.ObjectBean;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;//这个注解表示该类为mybatis的mapper类//也可以在项目启动类中使用@MapperScan(&quot;com.rsgis.mapper&quot;)来扫描所有mapper接口@Mapper//将接口的实现类交给Spring进行管理@Repositorypublic interface MySQLMapper &#123; List&lt;ObjectBean&gt; getAllObject();&#125; 构建访问实现文件在resource/mapper/MySQLMapper.xml中实现接口对应的SQL语句，namespace要填写访问数据库接口类文件路径 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.rsgis.mapper.MySQLMapper&quot;&gt; &lt;select id=&quot;getAllObject&quot; resultType=&quot;com.rsgis.bean.ObjectBean&quot; useCache=&quot;true&quot;&gt; select * from objects &lt;/select&gt; &lt;update id=&quot;UpdateFunction&quot; parameterType=&quot;com.rsgis.bean.FunctionBean&quot;&gt; update functions set req_num = #&#123;req_num&#125; where function_ID = #&#123;function_ID&#125;; &lt;/update&gt;&lt;/mapper&gt; 测试连接在test/java/com/rsgis/GisMonitorApplicationTests内构造测试代码并输出结果 12345678910111213@SpringBootTestclass GisMonitorApplicationTests &#123; @Autowired private MySQLMapper mySQLMapper; @Test void contextLoads() &#123; List&lt;ObjectBean&gt; allObjects = mySQLMapper.getAllObject(); System.out.println(allObjects); &#125;&#125; 输出结果如下，数据库连接正常 Error：SQL语句提示“应为标记名称” 在写SQL语句时，发现 &lt; 号报错了，经查询发现是mybatis做了转义，对应表格如下： mybatis转义对应表 原始 转义 原始 转义 &lt; &amp;lt; &gt;&#x3D; &amp;gt;&#x3D; &lt;&#x3D; &amp;lt;&#x3D; &amp; &amp;amp; &gt; &amp;gt; ‘ &amp;apos; “ &amp;quot;"},{"title":"新建SpringBoot项目","path":"/wiki/GISMonitor/CreateSpringBoot.html","content":"新建项目通过IDEA新建SpringBoot项目，并勾选Spring Web 然后在resources文件夹下新建banner.txt，放入可爱的猫猫 1234 |\\__/,| (`\\ |_ _ |.--.) ) ( T ) /(((^_(((/(((_/ Error: 端口占用新建完成后运行，发现报错端口被占用 使用cmd命令查看被占用的端口 1netstat -ano | findstr 端口号 得到对应的进程号，通过任务管理器进行PID排序查找，发现居然是TIM？ 把TIM关了就可以正常运行了"},{"title":"FGDCChecker","path":"/wiki/GISMonitor/FGDCChecker.html","content":"FGDC介绍FGDC,即美国联邦地理数据委员会（FederalGeodata Commission），其提供了服务状态检查器（Service Status Checker ，SSC）来验证、测试和评分地理空间 Web 服务。 在这里，我们使用liveTest API来测试我们监测的服务状态，作为综合评分的参考。 Supported API Method: GETRequest Format: https://statuschecker.fgdc.gov/api/v2/liveTest?auth=&amp;type&#x3D;&amp;url&#x3D;&amp;[other &#x3D; pairs] 结果解析设置返回格式为XML，使用jdom2进行解析，在pom.xml中引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.jdom&lt;/groupId&gt; &lt;artifactId&gt;jdom2&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt; JDOM操作xml常用类Document：表示整个xml文档，是一个树形结构Eelment：表示一个xml的元素，提供方法操作其子元素，如文本，属性和名称空间等Attribute：表示元素包含的属性Text：表示xml文本信息XMLOutputter：xml输出流，底层是通过JDK中流实现Format：提供xml文件输出的编码、样式和排版等设置 一个示例返回文档如下： 可以发现，我们关心的属性位于response/service/summary/scoredTest/performance下，相应的解析代码如下： 1234567891011121314SAXBuilder parser = new SAXBuilder();Document FGDCDoc = parser.build(FGDCRequestURL);Element RootEle = FGDCDoc.getRootElement();Element Service = RootEle.getChild(&quot;service&quot;, RootEle.getNamespace());Element summary = Service.getChild(&quot;summary&quot;, RootEle.getNamespace());Element scoredTest = summary.getChild(&quot;scoredTest&quot;, RootEle.getNamespace());List&lt;Element&gt; performance = scoredTest.getChildren(&quot;performance&quot;, RootEle.getNamespace());fp.setFGDC_time(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime()));Element currentScore = performance.get(1);String scoreString = currentScore.getValue();fp.setFGDC_score(Float.parseFloat(scoreString));Element currentSpeed = performance.get(0);String currentSpeedString = currentSpeed.getValue();fp.setFGDC_speed(Float.parseFloat(currentSpeedString)); 其中，FGDC_score为FGDC基于web服务 速度性能 和 响应正确性 所给出的综合打分（百分制），FGDC_speed为测试所用耗时（秒） 同时，FGDC还进行了一系列测试，将测试成功与否存于路径response/service/test下，解析代码如下： 1234567891011121314151617181920//&lt;!-- 0 = Failed, 1 = Success, 2 = IP banned - Not tested and -99.99 = Not tested --&gt;List&lt;Element&gt; testList = Service.getChildren(&quot;test&quot;, RootEle.getNamespace());for (Element element : testList) &#123; if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;httpServer&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setHttpServerSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;getCapabilities&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGetCapabilitiesSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;generatedGetCapabilities&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGeneratedGetCapabilitiesSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;getMap&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGetMapSuccess(Float.parseFloat(output.getValue())); &#125;&#125; 详细代码FGDCChecker.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@NoArgsConstructor@AllArgsConstructorpublic class FGDCChecker &#123; private String URL; public FGDCPerformance GetFGDCPerformance()&#123; FGDCPerformance fp = new FGDCPerformance(); String FGDCRequestURL = &quot;https://statuschecker.fgdc.gov/api/v2/liveTest?auth=&#123;yourKey&#125;&amp;type=WMS&amp;url=&quot; + this.URL + &quot;&amp;formattype=XML&quot;; try &#123; SAXBuilder parser = new SAXBuilder(); Document FGDCDoc = parser.build(FGDCRequestURL); Element RootEle = FGDCDoc.getRootElement(); Element Service = RootEle.getChild(&quot;service&quot;, RootEle.getNamespace()); Element summary = Service.getChild(&quot;summary&quot;, RootEle.getNamespace()); Element scoredTest = summary.getChild(&quot;scoredTest&quot;, RootEle.getNamespace()); List&lt;Element&gt; performance = scoredTest.getChildren(&quot;performance&quot;, RootEle.getNamespace()); fp.setFGDC_time(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime())); Element currentScore = performance.get(1); String scoreString = currentScore.getValue(); fp.setFGDC_score(Float.parseFloat(scoreString)); Element currentSpeed = performance.get(0); String currentSpeedString = currentSpeed.getValue(); fp.setFGDC_speed(Float.parseFloat(currentSpeedString));// &lt;!-- 0 = Failed, 1 = Success, 2 = IP banned - Not tested and -99.99 = Not tested --&gt; List&lt;Element&gt; testList = Service.getChildren(&quot;test&quot;, RootEle.getNamespace()); for (Element element : testList) &#123; if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;httpServer&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setHttpServerSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;getCapabilities&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGetCapabilitiesSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;generatedGetCapabilities&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGeneratedGetCapabilitiesSuccess(Float.parseFloat(output.getValue())); &#125; else if (element.getAttributeValue(&quot;type&quot;).compareTo(&quot;getMap&quot;) == 0) &#123; Element output = element.getChild(&quot;output&quot;, RootEle.getNamespace()); fp.setGetMapSuccess(Float.parseFloat(output.getValue())); &#125; &#125; return fp; &#125; catch (Exception e) &#123; fp.setFGDC_time(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime())); fp.setFGDC_score(-1); fp.setFGDC_speed(-1); fp.setHttpServerSuccess(-1); fp.setGetCapabilitiesSuccess(-1); fp.setGeneratedGetCapabilitiesSuccess(-1); fp.setGetMapSuccess(-1); return fp; &#125; &#125;&#125;"},{"title":"CurlCmd","path":"/wiki/GISMonitor/CurlCmd.html","content":"请求参数对数字资产对象的监测通过Curl进行，其请求参数如下表所示： Parameters Interpretation -L 自动重定向，当前资源已经移至其他地址时，自动重定向到新的地址 -k 解除curl的安全认证（不解除有的服务就会报60错误） –connect-timeout [seconds] 设置最大连接时间（后接时间） -m&#x2F;–max-time [seconds] 设置最大操作总时间（后接时间） -w 按照后面的格式写出返回消息 time_namelookup DNS解析域名的时间 time_connect client和server端建立TCP连接的时间（包括解析域名的时间） time_starttransfer 从开始到server 响应第一个字节的时间，即发送请求和服务器响应的时间之和（包括前面2个时间） time_total 从开始到server发送完所有的响应数据，并关闭连接的时间（包括前面所有时间） speed_download 下载速度，单位byte&#x2F;s http_code 返回的HTTP状态码 size_download 返回内容大小，单位byte content_type 返回内容的格式 Request示例curl -L -k –connect-timeout 30 -m 60 -w “ ”%{time_namelookup}::%{time_connect}::%{time_starttransfer}::%{time_total}::%{speed_download}::%{http_code}::%{size_download}::%{content_type}” ” URL 返回说明返回内容格式Curl在不同环境下返回的格式不同： Windows环境：Windows环境下返回的内容最后一行即为上述请求参数的结果，以“::”分开。 Linux环境：Linux环境下返回内容的格式和Windows相同，但需注意的是Linux下输入命令和输出结果的每一行都会自动加上双引号，所以代码中Linux环境下输入命令的url前后都不需加双引号，否则协议会被视为http而导致命令无法执行；返回结果中由于最后一行是一个双引号，所以要取倒数第二行，同时倒数第二行也会自动加上双引号，要进行处理。 12345678910111213141516//输入命令处理if (this.osName.startsWith(&quot;Windows&quot;)) &#123; curlCmd = &quot;curl -L -k --connect-timeout &quot; + con_timeout + &quot; -m &quot; + ope_timeout + &quot; -w \\&quot;\\ \\&quot;%&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;::%&#123;http_code&#125;::%&#123;size_download&#125;::%&#123;content_type&#125;\\&quot;\\ \\&quot; \\&quot;&quot; + url + &quot;\\&quot;&quot;;&#125; else if ((this.osName.contains(&quot;Linux&quot;)) || (this.osName.contains(&quot;CentOS&quot;))) &#123; curlCmd = &quot;curl -L -k --connect-timeout &quot; + con_timeout + &quot; -m &quot; + ope_timeout + &quot; -w \\&quot;\\ \\&quot;%&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;::%&#123;http_code&#125;::%&#123;size_download&#125;::%&#123;content_type&#125;\\&quot;\\ \\&quot; &quot; + url;&#125;//返回结果处理if (this.osName.startsWith(&quot;Windows&quot;)) &#123; mess = response.get(size1 - 1);&#125; else if ((this.osName.contains(&quot;Linux&quot;)) || (osName.contains(&quot;CentOS&quot;))) &#123; String messT = response.get(size1 - 2); mess = messT.substring(1, messT.length() - 1);&#125; 返回内容处理由于使用curl工具时，命令行内显示的是inputstream，即命令执行的结果；同时命令还会产生错误流errorstream，显示每隔一段时间接受数据量、下载速度等内容，会不断生成。输出缓冲区的size有限，如果不及时处理这两个流，就会发生阻塞，失去响应，所以程序中另外开了一个线程去读取错误流，保证两个流都及时的被读取，防止发生阻塞。 1234567891011121314151617181920212223242526272829303132333435363738Process process = Runtime.getRuntime().exec(curlCmd);final InputStreamReader ir1 = new InputStreamReader(process.getInputStream(), &quot;GBK&quot;);final InputStreamReader ir2 = new InputStreamReader(process.getErrorStream(), &quot;GBK&quot;);BufferedReader br1 = new BufferedReader(ir1);String line = null;final List&lt;String&gt; response = new ArrayList&lt;String&gt;();final List&lt;String&gt; errs = new ArrayList&lt;String&gt;();//这里，如果无法正常curl，就会不断产生errorStream,因为输出缓冲区的size有限，如果不及时处理的话就会卡住，所以这里要同时处理errorStream;//但是如果能正常curl的话，如果不及时处理inputStream也会卡住；要及时读取那个不断生成的流Thread thread = new Thread(() -&gt; &#123; BufferedReader br2 = new BufferedReader(ir2); try &#123; String line2 = null; while ((line2 = br2.readLine()) != null) &#123; if (!&quot;&quot;.equals(line2)) &#123; errs.add(line2); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ir2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);thread.start();while ((line = br1.readLine()) != null) &#123; if (!&quot;&quot;.equals(line)) &#123; response.add(line); &#125;&#125;thread.join();int exitValue = process.waitFor();process.destroy();ir1.close(); 返回内容解析返回内容提取最后一行或倒数第二行，按照“::”进行分割，一般情况下得到8个字符串，但是当curl失败时，最后一个参数“content_type”的返回结果为空，则得到7个字符串，需要单独处理。 返回内容经分割后，分别对应请求中各参数的结果，其中分为2大类结果，分别是Curl成功和Curl不成功，对应命令的exitvalue为0和不为0。 具体分类见下表： cURL默认连接超时时间为20秒，即–connect-timeout参数设置为20秒以上时，仍然会以20秒作为最大连接时间。 当达到默认最大连接时间（即20秒）仍未连接上时会报7错误；当达到用户设定最大连接时间（只有设置小于20秒才有效）仍未连接上时会报28错误；当总操作时间达到用户设定最大操作时间（即-m参数）仍未完成时报28错误。 即7错误是达到默认连接超时时间的错误，28错误是达到用户设置超时时间的错误。 返回结果存储 Database Field Convertion Interpretation statusCode Original + Self-Define 按照上表方式处理 connect_time time_connect - time_namelookup 截止到建立完TCP连接的时间减去截止到解析完域名的时间 server_time time_starttransfer - time_connect 截止到Server响应第一个字节的时间减去截止到建立完TCP连接的时间 transfer_time time_total - time_starttransfer 总时间减去截止到server响应第一个字节的时间 total_time time_total 原内容 download_speed speed_download 原内容 data_byte size_download 原内容 content_type content_type 原内容 计算公式为： total_time&nbsp;=&nbsp;namelookup_time&nbsp;+&nbsp;connect_time&nbsp;+&nbsp;server_time&nbsp;+&nbsp;transfer_time 整个请求过程可以描述为： 域名解析&nbsp;→&nbsp;建立TCP连接（三次握手）&nbsp;→&nbsp;发送http的Get请求（请求能力文档或图层）&nbsp;→&nbsp;服务器处理&nbsp;→&nbsp;传输数据（能力文档或图层） 其中下载速度是指整个过程的平均下载速度，即download_speed&nbsp;=&nbsp;data_byte/total_time server_time实际上包含了发送Get请求的时间和服务器响应时间两个时间，无法分开。 需要注意的是，curl如果失败的话，返回的各种时间就会错乱，只有总时间始终有效，所以在数据库存储过程中，curl失败的情况只有total_time始终有效，其他时间可能记录为0。 详细代码CurlCmd.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package com.rsgis.utils;import com.rsgis.bean.CurlResponse;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.math.BigDecimal;import java.math.RoundingMode;import java.util.ArrayList;import java.util.List;import java.util.Objects;@NoArgsConstructor@AllArgsConstructorpublic class CurlCmd &#123; private String url; private int con_timeout; private int ope_timeout; private String osName; public CurlResponse doCurlCmd() throws InterruptedException &#123; try &#123; String curlCmd = null; //linux中在处理和输出字符串时会自动加双引号！！！ if (this.osName.startsWith(&quot;Windows&quot;)) &#123; curlCmd = &quot;curl -L -k --connect-timeout &quot; + con_timeout + &quot; -m &quot; + ope_timeout + &quot; -w \\&quot;\\ \\&quot;%&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;::%&#123;http_code&#125;::%&#123;size_download&#125;::%&#123;content_type&#125;\\&quot;\\ \\&quot; \\&quot;&quot; + url + &quot;\\&quot;&quot;; &#125; else if ((this.osName.contains(&quot;Linux&quot;)) || (this.osName.contains(&quot;CentOS&quot;))) &#123; curlCmd = &quot;curl -L -k --connect-timeout &quot; + con_timeout + &quot; -m &quot; + ope_timeout + &quot; -w \\&quot;\\ \\&quot;%&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;::%&#123;http_code&#125;::%&#123;size_download&#125;::%&#123;content_type&#125;\\&quot;\\ \\&quot; &quot; + url; &#125; Process process = Runtime.getRuntime().exec(curlCmd); final InputStreamReader ir1 = new InputStreamReader(process .getInputStream(), &quot;GBK&quot;); final InputStreamReader ir2 = new InputStreamReader(process .getErrorStream(), &quot;GBK&quot;); BufferedReader br1 = new BufferedReader(ir1); String line = null; final List&lt;String&gt; response = new ArrayList&lt;String&gt;(); final List&lt;String&gt; errs = new ArrayList&lt;String&gt;(); //这里，如果无法正常curl，就会不断产生errorStream,因为输出缓冲区的size有限，如果不及时处理的话就会卡住，所以这里要同时处理errorStream; //但是如果能正常curl的话，如果不及时处理inputStream也会卡住；要及时读取那个不断生成的流 Thread thread = new Thread(() -&gt; &#123; BufferedReader br2 = new BufferedReader(ir2); try &#123; String line2 = null; while ((line2 = br2.readLine()) != null) &#123; if (!&quot;&quot;.equals(line2)) &#123; errs.add(line2); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ir2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); while ((line = br1.readLine()) != null) &#123; if (!&quot;&quot;.equals(line)) &#123; response.add(line); &#125; &#125; thread.join(); int exitValue = process.waitFor(); process.destroy(); ir1.close(); return parseMessage(response, exitValue); &#125; catch (IOException e) &#123; System.out.println(&quot;IOException &quot; + e.getMessage()); return null; &#125; &#125; private CurlResponse parseMessage(List&lt;String&gt; response, int exitValue) &#123; int size1 = response.size(); CurlResponse cr = new CurlResponse(); if (size1 == 0) &#123; cr.setTime_connect(0); cr.setTime_server(0); cr.setTime_transfer(0); cr.setTime_total(0); cr.setData_size(0); cr.setDownload_speed(0); cr.setStatusCode(700); cr.setContentType(&quot;&quot;); return cr; &#125; else &#123; String mess = null; if (this.osName.startsWith(&quot;Windows&quot;)) &#123; mess = response.get(size1 - 1); &#125; else if ((this.osName.contains(&quot;Linux&quot;)) || (osName.contains(&quot;CentOS&quot;))) &#123; String messT = response.get(size1 - 2); mess = messT.substring(1, messT.length() - 1); &#125; assert mess != null; String[] message = mess.split(&quot;::&quot;); String type = null; if (message.length == 8) &#123; type = message[7].toLowerCase(); &#125; else &#123; type = &quot;&quot;; &#125; boolean valid = false; if (exitValue == 0) &#123; valid = ContentValid(response,type);//判断返回内容是否有效 &#125; float time0 = Float.parseFloat(message[0]); float time1 = Float.parseFloat(message[1]); float time2 = Float.parseFloat(message[2]); float time3 = Float.parseFloat(message[3]); int code = Integer.parseInt(message[5]); String data_type = type; float connect, server, tran, total, speed; float result_speed, result_connect, result_server, result_tran, result_total; if (exitValue == 0) &#123; connect = time1 - time0; server = time2 - time1; tran = time3 - time2; &#125; else &#123; connect = 0; server = 0; tran = 0; &#125; total = time3; speed = Float.parseFloat(message[4]); BigDecimal bg1 = new BigDecimal(speed); BigDecimal bg2 = new BigDecimal(connect); BigDecimal bg3 = new BigDecimal(server); BigDecimal bg4 = new BigDecimal(tran); BigDecimal bg5 = new BigDecimal(total); result_speed = bg1.setScale(3, RoundingMode.HALF_UP).floatValue(); result_connect = bg2.setScale(3, RoundingMode.HALF_UP).floatValue(); result_server = bg3.setScale(3, RoundingMode.HALF_UP).floatValue(); result_tran = bg4.setScale(3, RoundingMode.HALF_UP).floatValue(); result_total = bg5.setScale(3, RoundingMode.HALF_UP).floatValue(); cr.setContentType(data_type); cr.setTime_connect(result_connect); cr.setTime_transfer(result_tran); cr.setTime_server(result_server); cr.setTime_total(result_total); cr.setData_size(Integer.parseInt(message[6])); cr.setDownload_speed(result_speed); if (exitValue != 0)//IOException, curl failed &#123; cr.setStatusCode(exitValue); &#125; else &#123;//curl succes if ((code == 200) &amp;&amp; (!valid))//invalid services or layers &#123; cr.setStatusCode(600);;//self-defined statusCode &#125; else//valid services or layers &#123; cr.setStatusCode(code); &#125; &#125; return cr; &#125; &#125;&#125;"},{"title":"定时任务","path":"/wiki/GISMonitor/MonitorSchedule.html","content":"根据需要，新建MonitorSchedule类来实现监测服务的定时运行 基于注解（@Scheduled）基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响。 @EnableScheduling : 在配置类上使用，开启计划任务的支持 @Scheduled : 来声明这是一个任务，包括 cron，fixDelay，fixRate 等类型 定时调用监测服务12345678910111213141516171819@Service@EnableSchedulingpublic class MonitorSchedule &#123; @Value(&quot;$&#123;settings.monitor.startIndex&#125;&quot;) private int index; @Value(&quot;$&#123;settings.monitor.partition&#125;&quot;) private int partition; private String monitorIP; @Autowired private MonitorService monitorService; @Scheduled(fixedDelayString = &quot;$&#123;settings.monitor.fixedDelay:600000&#125;&quot;,initialDelay = 3000) public void FunctionTimerTask() &#123; String newIP = new GetMonitorIP().GetIP(); if(newIP!=null)&#123;monitorIP = newIP;&#125; monitorService.FunctionMonitor(index,monitorIP); index=(index+1)%partition; &#125;&#125; @Scheduled - CronScheduled注解类源码1234567891011121314151617181920212223242526272829303132package org.springframework.scheduling.annotation; import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; @Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(Schedules.class)public @interface Scheduled &#123; String CRON_DISABLED = &quot;-&quot;; String cron() default &quot;&quot;; String zone() default &quot;&quot;; long fixedDelay() default -1L; String fixedDelayString() default &quot;&quot;; long fixedRate() default -1L; String fixedRateString() default &quot;&quot;; long initialDelay() default -1L; String initialDelayString() default &quot;&quot;;&#125; cron 表达式语法：秒 分 小时 日 月 周 年 1@Scheduled(cron = &quot;0/5 * * * * ?&quot;) 说明 是否必填 允许填写的值 允许的通配符 秒 是 0-59 , - * &#x2F; 分 是 0-59 , - * &#x2F; 小时 是 0-23 , - * &#x2F; 日 是 1-31 , - * ? &#x2F; L W 月 是 1-12 or JAN-DEC , - * &#x2F; 周 是 1-7 or MON-SUN , - * ? &#x2F; L # 年 否 empty 或 1970-2099 , - * &#x2F; 通配符含义, : 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发- : 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发* : 表示所有值. 例如:在分的字段上设置,表示每一分钟都会触发&#x2F; : 用于递增触发。如在秒上面设置”5&#x2F;15” 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置’1&#x2F;3’所示每月1号开始，每隔三天触发一次L : 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年), 在周字段上表示星期天，相当于”7”或”SUN”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期六”W : 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发，如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“).LW : 表示在本月的最后一个工作日触发# : 表示每月的第几个周几，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”6#5”,正好第五周没有周六，则不会触发该配置 @Scheduled - Zone时区，接收一个 java.util.TimeZone#ID 。cron表达式会基于该时区解析，默认是一个空字符串，即取服务器所在地的时区。 1@Scheduled(cron =&quot;0 0 14 * * *&quot;, zone =&quot;GMT-5&quot;) @Scheduled - fixedDelay上一次 执行完毕 时间点之后多长时间再执行: 1@Scheduled(fixedDelay = 5000) //上一次执行完毕时间点之后5秒再执行 @Scheduled - fixedDelayString与fixedDelay意思相同，只是使用字符串的形式，支持占位符： 123@Scheduled(fixedDelayString = &quot;5000&quot;) //上一次执行完毕时间点之后5秒再执行//占位符@Scheduled(fixedDelayString = &quot;$&#123;settings.monitor.fixedDelay:5000&#125;&quot;) //根据配置文件设置间隔，默认上一次执行完毕时间点之后5秒再执行 @Scheduled - fixedRate上一次 开始执行 时间点之后多长时间再执行： 1@Scheduled(fixedRate = 5000) //上一次开始执行时间点之后5秒再执行 @Scheduled - fixedRateString与fixedRate意思相同，只是使用字符串的形式，支持占位符： 123@Scheduled(fixedRateString = &quot;5000&quot;) //上一次开始执行时间点之后5秒再执行//占位符@Scheduled(fixedRateString = &quot;$&#123;settings.monitor.fixedRate:5000&#125;&quot;) //根据配置文件设置间隔，默认上一次开始执行时间点之后5秒再执行 @Scheduled - initialDelay 第一次 延迟多长时间后再执行： 1@Scheduled(initialDelay=1000, fixedRate=5000) //第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 @Scheduled - initialDelayString与initialDelay意思相同，只是使用字符串的形式，支持占位符: 1@Scheduled(initialDelay=&quot;$&#123;settings.monitor.initialDelay:1000&#125;&quot;, fixedRate=5000) ////根据配置文件设置间隔，默认第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次"},{"title":"监测服务","path":"/wiki/GISMonitor/MonitorService.html","content":"之前已经完成了Curl监测与FGDC检查两大工具类的构建，接下来将构建监测服务类，分为监测服务接口类、监测服务实现类与异步监测服务类 整个监测过程可以描述为： 获取待检测对象&nbsp;→&nbsp;多线程并行化监测&nbsp;→&nbsp;监测结果入库 线程池配置详细代码123456789101112131415161718192021222324@Configuration@EnableAsyncpublic class AsyncConfiguration &#123; @Bean(&quot;async&quot;) public Executor asyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 核心线程数：线程池创建时候初始化的线程数 executor.setCorePoolSize(32); // 最大线程数：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程 executor.setMaxPoolSize(64); // 缓冲队列：用来缓冲执行任务的队列 executor.setQueueCapacity(512); // 允许线程的空闲时间60秒：当超过了核心线程之外的线程在空闲时间到达之后会被销毁 executor.setKeepAliveSeconds(60); // 线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池 executor.setThreadNamePrefix(&quot;asyncExecutor-&quot;); // 缓冲队列满了之后的拒绝策略：由调用线程处理（一般是主线程） executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; &#125;&#125; SpringBoot使用的多线程方式非常简单，在需要异步的方法上加@Async(&quot;线程池名称&quot;)注解 ThreadPoolExecutor的拒绝策略AbortPolicyThreadPoolExecutor中默认的拒绝策略为AbortPolicy：12345678public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125;即直接抛出异常，并不再执行任务 CallerRunsPolicy该策略会在任务被拒绝添加后，调用当前线程池的所在的线程去执行被拒绝的任务：12345678public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125;该策略会导致主线程堵塞 DiscardPolicy该策略会将拒绝的任务直接丢弃，同时不抛出异常：12345public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; DiscardOldestPolicy该策略会在出现拒绝添加的任务时，从任务队列总弹出最先加入的任务（即Oldest），空出一个位置，然后再次执行execute方法把任务加入队列：123456789public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; 监测服务接口类1234public interface MonitorService &#123; public List&lt;FunctionBean&gt; GetFunctionList(int index); public void FunctionMonitor(int index) throws InterruptedException;&#125; 监测服务实现类详细代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Servicepublic class MonitorServiceImpl implements MonitorService &#123; @Autowired private MySQLMapper mySQLMapper; @Autowired private MonitorAsyncServer monitorAsyncServer; @Override public List&lt;FunctionBean&gt; GetFunctionList(int index) &#123; try &#123; return mySQLMapper.GetFunctionList(index); &#125;catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; @Override public void FunctionMonitor(int index) throws InterruptedException &#123; String monitorIP = new GetMonitorIP().GetIP();//获取监测点IP String osName = System.getProperties().getProperty(&quot;os.name&quot;);//获取监测点操作系统名 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;); Calendar cal = Calendar.getInstance(); List&lt;FunctionBean&gt; functionList = GetFunctionList(index);//获取待检测对象列表 CountDownLatch countDownLatch = new CountDownLatch(functionList.size()); System.out.println(&quot; ----------------------------------------------------------- &quot; + &quot;FunctionMonitor StartTime : &quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime())+ &quot; ( &quot;+monitorIP+&quot; - &quot;+osName+&quot; )&quot;); System.out.println(&quot;Monitor index-Size : &quot; +index+&quot; - &quot;+functionList.size()); for (FunctionBean function : functionList) &#123; monitorAsyncServer.FunctionMonitor(countDownLatch, monitorIP, osName,function); &#125; try &#123; countDownLatch.await(settingProperties.getMonitor().getCountDownLatchTimeout(), TimeUnit.MINUTES); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;Exception: await interrupted exception&quot;); &#125; finally &#123; System.out.println(&quot;countDownLatch: &quot; + countDownLatch.getCount()+&quot; (should be 0)&quot;); &#125; System.out.println(&quot;Monitor Finish at &quot;+new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance().getTime())); &#125;&#125; 在监测服务实现类中调用异步检测服务类MonitorAsyncServer实现对象的多线程异步监测。 为保证所有线程运行完后再执行下一步，加入CountDownLatch使代码修改为阻塞式： countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。 异步检测服务类在方法前加上注释 @Async(&quot;async&quot;) 声明此方法可使用多线程 详细代码1234567891011121314151617181920212223242526272829303132@Servicepublic class MonitorAsyncServer &#123; @Autowired MySQLMapper mySQLMapper; @Autowired private SettingProperties settingProperties; @Async(&quot;async&quot;) public void FunctionMonitor(CountDownLatch countDownLatch, String ip, String osName, FunctionBean function) &#123; //FGDC监测 FGDCPerformance fp = new FGDCChecker(function.getFunction_URL()).GetFGDCPerformance(); //Curl监测 CurlCmd cc = new CurlCmd(function.getFunction_URL(), function.getFunction_type(),function.getObject_type(), settingProperties.getCurl().getConnectionTimeOut(),settingProperties.getCurl().getOperationTimeOut(),osName); try &#123; CurlResponse cr = cc.doCurlCmd(); //处理并入库 UpdateFunction(function); AddFunctionPerformanceHistory(ip,function,fp,cr); //System.out.println(&quot;线程池&quot; + Thread.currentThread().getName()+&quot; - &quot;+countDownLatch.getCount()); countDownLatch.countDown(); &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); countDownLatch.countDown(); &#125; &#125;&#125; 多线程监测测试结果："},{"title":"配置文件读取","path":"/wiki/GISMonitor/SettingProperties.html","content":"Spring Boot读取配置文件常用方式@Value方式获取1234567//org.springframework.beans.factory.annotation.Value@Value($&#123;配置项key:默认值&#125;)private String configValue;//for example@Value(&quot;$&#123;value.request.timeout:20&#125;&quot;)private int timeOut; Environment对象获取1234567//org.springframework.core.env.Environment@Autowiredprivate Environment environment;//for exampleenvironment.getProperty(&quot;value.request.timeout&quot;) @ConfigurationProperties方式获取在application.yml中： 12345settings: name: ove curl: ConnectionTimeOut: 30 OperationTimeOut: 60 则对应的配置类为： 12345678910111213141516171819import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Data@Component@ConfigurationProperties(value = &quot;settings&quot;)public class SettingProperties &#123; private String name; private Curl curl; @Data public static class Curl &#123; private int ConnectionTimeOut; private int OperationTimeOut; &#125;&#125; 注意事项@ConfigurationProperties(value &#x3D; “settings”) 表示配置文件里属性的前缀是 settings配置类上记得加上 @Data 和 @Component 注解（或者在启动类上加上 @EnableConfigurationProperties(value &#x3D; AppProperties.class) ）如果有内部类对象，记得加上 @Data ，不然无法映射数据 使用方法： 12@Autowiredprivate SettingProperties settingProperties; @PropertySource方式获取有时候我们会有一些特殊意义的配置，会 单独 用一个配置文件存储，比如数据库配置连接参数(在application.yml同级目录新建一个配置文件) 则对应的配置类为： 12345678910@Data@Component@ConfigurationProperties(value = &quot;others&quot;)@PropertySource(value = &quot;classpath:others.properties&quot;, encoding = &quot;UTF-8&quot;, ignoreResourceNotFound = true)public class OtherSettingProperties &#123; private String userName; private String userAge;&#125; 注意事项@ConfigurationProperties(value &#x3D; “others”) 表示配置文件里属性的前缀是 others@PropertySource 中 value 属性表示指定配置文件的路径，encoding 属性表示指定的是读取配置文件时的编码，记得和文件 alian.properties 的编码保持一致，ignoreResourceNotFound 属性值为true时没找到指定配置文件的时候不报错配置类上记得加上 @Component 注解.yml 格式不支持 @PlaceSource 注解导入配置 使用方法： 12@Autowiredprivate OtherSettingProperties otherSettingProperties;"},{"title":"项目简介","path":"/wiki/GISMonitor/index.html","content":"数字资产对象定义本项目监测的数字资产对象包含：满足OGC标准的网络服务，包括WMS、WFS、WCS、WMTS、CSW等；视频；论文数据；计算机资源状态 项目需求原先已开发完成OGC网络服务的检测组件，但原始代码较为混乱，逻辑不够清晰，同时不能满足为前端提供接口的需求，故基于SpringBoot对原项目进行重构"}]